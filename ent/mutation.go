// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"fstiffo/pills/ent/activeingredient"
	"fstiffo/pills/ent/consumptionlog"
	"fstiffo/pills/ent/medicine"
	"fstiffo/pills/ent/predicate"
	"fstiffo/pills/ent/prescription"
	"fstiffo/pills/ent/purchase"
	"fstiffo/pills/ent/stockinglog"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeActiveIngredient = "ActiveIngredient"
	TypeConsumptionLog   = "ConsumptionLog"
	TypeMedicine         = "Medicine"
	TypePrescription     = "Prescription"
	TypePurchase         = "Purchase"
	TypeStockingLog      = "StockingLog"
)

// ActiveIngredientMutation represents an operation that mutates the ActiveIngredient nodes in the graph.
type ActiveIngredientMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	name                 *string
	clearedFields        map[string]struct{}
	medicines            map[int]struct{}
	removedmedicines     map[int]struct{}
	clearedmedicines     bool
	prescriptions        map[int]struct{}
	removedprescriptions map[int]struct{}
	clearedprescriptions bool
	done                 bool
	oldValue             func(context.Context) (*ActiveIngredient, error)
	predicates           []predicate.ActiveIngredient
}

var _ ent.Mutation = (*ActiveIngredientMutation)(nil)

// activeingredientOption allows management of the mutation configuration using functional options.
type activeingredientOption func(*ActiveIngredientMutation)

// newActiveIngredientMutation creates new mutation for the ActiveIngredient entity.
func newActiveIngredientMutation(c config, op Op, opts ...activeingredientOption) *ActiveIngredientMutation {
	m := &ActiveIngredientMutation{
		config:        c,
		op:            op,
		typ:           TypeActiveIngredient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActiveIngredientID sets the ID field of the mutation.
func withActiveIngredientID(id int) activeingredientOption {
	return func(m *ActiveIngredientMutation) {
		var (
			err   error
			once  sync.Once
			value *ActiveIngredient
		)
		m.oldValue = func(ctx context.Context) (*ActiveIngredient, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActiveIngredient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActiveIngredient sets the old ActiveIngredient of the mutation.
func withActiveIngredient(node *ActiveIngredient) activeingredientOption {
	return func(m *ActiveIngredientMutation) {
		m.oldValue = func(context.Context) (*ActiveIngredient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActiveIngredientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActiveIngredientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActiveIngredientMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActiveIngredientMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActiveIngredient.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ActiveIngredientMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ActiveIngredientMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ActiveIngredient entity.
// If the ActiveIngredient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActiveIngredientMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ActiveIngredientMutation) ResetName() {
	m.name = nil
}

// AddMedicineIDs adds the "medicines" edge to the Medicine entity by ids.
func (m *ActiveIngredientMutation) AddMedicineIDs(ids ...int) {
	if m.medicines == nil {
		m.medicines = make(map[int]struct{})
	}
	for i := range ids {
		m.medicines[ids[i]] = struct{}{}
	}
}

// ClearMedicines clears the "medicines" edge to the Medicine entity.
func (m *ActiveIngredientMutation) ClearMedicines() {
	m.clearedmedicines = true
}

// MedicinesCleared reports if the "medicines" edge to the Medicine entity was cleared.
func (m *ActiveIngredientMutation) MedicinesCleared() bool {
	return m.clearedmedicines
}

// RemoveMedicineIDs removes the "medicines" edge to the Medicine entity by IDs.
func (m *ActiveIngredientMutation) RemoveMedicineIDs(ids ...int) {
	if m.removedmedicines == nil {
		m.removedmedicines = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.medicines, ids[i])
		m.removedmedicines[ids[i]] = struct{}{}
	}
}

// RemovedMedicines returns the removed IDs of the "medicines" edge to the Medicine entity.
func (m *ActiveIngredientMutation) RemovedMedicinesIDs() (ids []int) {
	for id := range m.removedmedicines {
		ids = append(ids, id)
	}
	return
}

// MedicinesIDs returns the "medicines" edge IDs in the mutation.
func (m *ActiveIngredientMutation) MedicinesIDs() (ids []int) {
	for id := range m.medicines {
		ids = append(ids, id)
	}
	return
}

// ResetMedicines resets all changes to the "medicines" edge.
func (m *ActiveIngredientMutation) ResetMedicines() {
	m.medicines = nil
	m.clearedmedicines = false
	m.removedmedicines = nil
}

// AddPrescriptionIDs adds the "prescriptions" edge to the Prescription entity by ids.
func (m *ActiveIngredientMutation) AddPrescriptionIDs(ids ...int) {
	if m.prescriptions == nil {
		m.prescriptions = make(map[int]struct{})
	}
	for i := range ids {
		m.prescriptions[ids[i]] = struct{}{}
	}
}

// ClearPrescriptions clears the "prescriptions" edge to the Prescription entity.
func (m *ActiveIngredientMutation) ClearPrescriptions() {
	m.clearedprescriptions = true
}

// PrescriptionsCleared reports if the "prescriptions" edge to the Prescription entity was cleared.
func (m *ActiveIngredientMutation) PrescriptionsCleared() bool {
	return m.clearedprescriptions
}

// RemovePrescriptionIDs removes the "prescriptions" edge to the Prescription entity by IDs.
func (m *ActiveIngredientMutation) RemovePrescriptionIDs(ids ...int) {
	if m.removedprescriptions == nil {
		m.removedprescriptions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.prescriptions, ids[i])
		m.removedprescriptions[ids[i]] = struct{}{}
	}
}

// RemovedPrescriptions returns the removed IDs of the "prescriptions" edge to the Prescription entity.
func (m *ActiveIngredientMutation) RemovedPrescriptionsIDs() (ids []int) {
	for id := range m.removedprescriptions {
		ids = append(ids, id)
	}
	return
}

// PrescriptionsIDs returns the "prescriptions" edge IDs in the mutation.
func (m *ActiveIngredientMutation) PrescriptionsIDs() (ids []int) {
	for id := range m.prescriptions {
		ids = append(ids, id)
	}
	return
}

// ResetPrescriptions resets all changes to the "prescriptions" edge.
func (m *ActiveIngredientMutation) ResetPrescriptions() {
	m.prescriptions = nil
	m.clearedprescriptions = false
	m.removedprescriptions = nil
}

// Where appends a list predicates to the ActiveIngredientMutation builder.
func (m *ActiveIngredientMutation) Where(ps ...predicate.ActiveIngredient) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActiveIngredientMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActiveIngredientMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ActiveIngredient, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActiveIngredientMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActiveIngredientMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ActiveIngredient).
func (m *ActiveIngredientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActiveIngredientMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, activeingredient.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActiveIngredientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activeingredient.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActiveIngredientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activeingredient.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown ActiveIngredient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActiveIngredientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activeingredient.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown ActiveIngredient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActiveIngredientMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActiveIngredientMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActiveIngredientMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ActiveIngredient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActiveIngredientMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActiveIngredientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActiveIngredientMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ActiveIngredient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActiveIngredientMutation) ResetField(name string) error {
	switch name {
	case activeingredient.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown ActiveIngredient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActiveIngredientMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.medicines != nil {
		edges = append(edges, activeingredient.EdgeMedicines)
	}
	if m.prescriptions != nil {
		edges = append(edges, activeingredient.EdgePrescriptions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActiveIngredientMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activeingredient.EdgeMedicines:
		ids := make([]ent.Value, 0, len(m.medicines))
		for id := range m.medicines {
			ids = append(ids, id)
		}
		return ids
	case activeingredient.EdgePrescriptions:
		ids := make([]ent.Value, 0, len(m.prescriptions))
		for id := range m.prescriptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActiveIngredientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmedicines != nil {
		edges = append(edges, activeingredient.EdgeMedicines)
	}
	if m.removedprescriptions != nil {
		edges = append(edges, activeingredient.EdgePrescriptions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActiveIngredientMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case activeingredient.EdgeMedicines:
		ids := make([]ent.Value, 0, len(m.removedmedicines))
		for id := range m.removedmedicines {
			ids = append(ids, id)
		}
		return ids
	case activeingredient.EdgePrescriptions:
		ids := make([]ent.Value, 0, len(m.removedprescriptions))
		for id := range m.removedprescriptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActiveIngredientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmedicines {
		edges = append(edges, activeingredient.EdgeMedicines)
	}
	if m.clearedprescriptions {
		edges = append(edges, activeingredient.EdgePrescriptions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActiveIngredientMutation) EdgeCleared(name string) bool {
	switch name {
	case activeingredient.EdgeMedicines:
		return m.clearedmedicines
	case activeingredient.EdgePrescriptions:
		return m.clearedprescriptions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActiveIngredientMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ActiveIngredient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActiveIngredientMutation) ResetEdge(name string) error {
	switch name {
	case activeingredient.EdgeMedicines:
		m.ResetMedicines()
		return nil
	case activeingredient.EdgePrescriptions:
		m.ResetPrescriptions()
		return nil
	}
	return fmt.Errorf("unknown ActiveIngredient edge %s", name)
}

// ConsumptionLogMutation represents an operation that mutates the ConsumptionLog nodes in the graph.
type ConsumptionLogMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	consumed_at         *time.Time
	clearedFields       map[string]struct{}
	prescription        *int
	clearedprescription bool
	done                bool
	oldValue            func(context.Context) (*ConsumptionLog, error)
	predicates          []predicate.ConsumptionLog
}

var _ ent.Mutation = (*ConsumptionLogMutation)(nil)

// consumptionlogOption allows management of the mutation configuration using functional options.
type consumptionlogOption func(*ConsumptionLogMutation)

// newConsumptionLogMutation creates new mutation for the ConsumptionLog entity.
func newConsumptionLogMutation(c config, op Op, opts ...consumptionlogOption) *ConsumptionLogMutation {
	m := &ConsumptionLogMutation{
		config:        c,
		op:            op,
		typ:           TypeConsumptionLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConsumptionLogID sets the ID field of the mutation.
func withConsumptionLogID(id int) consumptionlogOption {
	return func(m *ConsumptionLogMutation) {
		var (
			err   error
			once  sync.Once
			value *ConsumptionLog
		)
		m.oldValue = func(ctx context.Context) (*ConsumptionLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ConsumptionLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConsumptionLog sets the old ConsumptionLog of the mutation.
func withConsumptionLog(node *ConsumptionLog) consumptionlogOption {
	return func(m *ConsumptionLogMutation) {
		m.oldValue = func(context.Context) (*ConsumptionLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConsumptionLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConsumptionLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConsumptionLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConsumptionLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ConsumptionLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetConsumedAt sets the "consumed_at" field.
func (m *ConsumptionLogMutation) SetConsumedAt(t time.Time) {
	m.consumed_at = &t
}

// ConsumedAt returns the value of the "consumed_at" field in the mutation.
func (m *ConsumptionLogMutation) ConsumedAt() (r time.Time, exists bool) {
	v := m.consumed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldConsumedAt returns the old "consumed_at" field's value of the ConsumptionLog entity.
// If the ConsumptionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumptionLogMutation) OldConsumedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsumedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsumedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsumedAt: %w", err)
	}
	return oldValue.ConsumedAt, nil
}

// ResetConsumedAt resets all changes to the "consumed_at" field.
func (m *ConsumptionLogMutation) ResetConsumedAt() {
	m.consumed_at = nil
}

// SetPrescriptionID sets the "prescription" edge to the Prescription entity by id.
func (m *ConsumptionLogMutation) SetPrescriptionID(id int) {
	m.prescription = &id
}

// ClearPrescription clears the "prescription" edge to the Prescription entity.
func (m *ConsumptionLogMutation) ClearPrescription() {
	m.clearedprescription = true
}

// PrescriptionCleared reports if the "prescription" edge to the Prescription entity was cleared.
func (m *ConsumptionLogMutation) PrescriptionCleared() bool {
	return m.clearedprescription
}

// PrescriptionID returns the "prescription" edge ID in the mutation.
func (m *ConsumptionLogMutation) PrescriptionID() (id int, exists bool) {
	if m.prescription != nil {
		return *m.prescription, true
	}
	return
}

// PrescriptionIDs returns the "prescription" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrescriptionID instead. It exists only for internal usage by the builders.
func (m *ConsumptionLogMutation) PrescriptionIDs() (ids []int) {
	if id := m.prescription; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrescription resets all changes to the "prescription" edge.
func (m *ConsumptionLogMutation) ResetPrescription() {
	m.prescription = nil
	m.clearedprescription = false
}

// Where appends a list predicates to the ConsumptionLogMutation builder.
func (m *ConsumptionLogMutation) Where(ps ...predicate.ConsumptionLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConsumptionLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConsumptionLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ConsumptionLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConsumptionLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConsumptionLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ConsumptionLog).
func (m *ConsumptionLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConsumptionLogMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.consumed_at != nil {
		fields = append(fields, consumptionlog.FieldConsumedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConsumptionLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case consumptionlog.FieldConsumedAt:
		return m.ConsumedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConsumptionLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case consumptionlog.FieldConsumedAt:
		return m.OldConsumedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ConsumptionLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConsumptionLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case consumptionlog.FieldConsumedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsumedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ConsumptionLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConsumptionLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConsumptionLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConsumptionLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ConsumptionLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConsumptionLogMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConsumptionLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConsumptionLogMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ConsumptionLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConsumptionLogMutation) ResetField(name string) error {
	switch name {
	case consumptionlog.FieldConsumedAt:
		m.ResetConsumedAt()
		return nil
	}
	return fmt.Errorf("unknown ConsumptionLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConsumptionLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.prescription != nil {
		edges = append(edges, consumptionlog.EdgePrescription)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConsumptionLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case consumptionlog.EdgePrescription:
		if id := m.prescription; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConsumptionLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConsumptionLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConsumptionLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprescription {
		edges = append(edges, consumptionlog.EdgePrescription)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConsumptionLogMutation) EdgeCleared(name string) bool {
	switch name {
	case consumptionlog.EdgePrescription:
		return m.clearedprescription
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConsumptionLogMutation) ClearEdge(name string) error {
	switch name {
	case consumptionlog.EdgePrescription:
		m.ClearPrescription()
		return nil
	}
	return fmt.Errorf("unknown ConsumptionLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConsumptionLogMutation) ResetEdge(name string) error {
	switch name {
	case consumptionlog.EdgePrescription:
		m.ResetPrescription()
		return nil
	}
	return fmt.Errorf("unknown ConsumptionLog edge %s", name)
}

// MedicineMutation represents an operation that mutates the Medicine nodes in the graph.
type MedicineMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	name                     *string
	mah                      *string
	dosage                   *float64
	adddosage                *float64
	unit                     *string
	atc                      *string
	_package                 *string
	form                     *string
	box_size                 *int
	addbox_size              *int
	stock                    *float32
	addstock                 *float32
	last_stock_update        *time.Time
	clearedFields            map[string]struct{}
	purchases                map[int]struct{}
	removedpurchases         map[int]struct{}
	clearedpurchases         bool
	stocking_logs            map[int]struct{}
	removedstocking_logs     map[int]struct{}
	clearedstocking_logs     bool
	active_ingredient        *int
	clearedactive_ingredient bool
	done                     bool
	oldValue                 func(context.Context) (*Medicine, error)
	predicates               []predicate.Medicine
}

var _ ent.Mutation = (*MedicineMutation)(nil)

// medicineOption allows management of the mutation configuration using functional options.
type medicineOption func(*MedicineMutation)

// newMedicineMutation creates new mutation for the Medicine entity.
func newMedicineMutation(c config, op Op, opts ...medicineOption) *MedicineMutation {
	m := &MedicineMutation{
		config:        c,
		op:            op,
		typ:           TypeMedicine,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMedicineID sets the ID field of the mutation.
func withMedicineID(id int) medicineOption {
	return func(m *MedicineMutation) {
		var (
			err   error
			once  sync.Once
			value *Medicine
		)
		m.oldValue = func(ctx context.Context) (*Medicine, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Medicine.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedicine sets the old Medicine of the mutation.
func withMedicine(node *Medicine) medicineOption {
	return func(m *MedicineMutation) {
		m.oldValue = func(context.Context) (*Medicine, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MedicineMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MedicineMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MedicineMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MedicineMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Medicine.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MedicineMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MedicineMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Medicine entity.
// If the Medicine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicineMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MedicineMutation) ResetName() {
	m.name = nil
}

// SetMah sets the "mah" field.
func (m *MedicineMutation) SetMah(s string) {
	m.mah = &s
}

// Mah returns the value of the "mah" field in the mutation.
func (m *MedicineMutation) Mah() (r string, exists bool) {
	v := m.mah
	if v == nil {
		return
	}
	return *v, true
}

// OldMah returns the old "mah" field's value of the Medicine entity.
// If the Medicine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicineMutation) OldMah(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMah is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMah requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMah: %w", err)
	}
	return oldValue.Mah, nil
}

// ResetMah resets all changes to the "mah" field.
func (m *MedicineMutation) ResetMah() {
	m.mah = nil
}

// SetDosage sets the "dosage" field.
func (m *MedicineMutation) SetDosage(f float64) {
	m.dosage = &f
	m.adddosage = nil
}

// Dosage returns the value of the "dosage" field in the mutation.
func (m *MedicineMutation) Dosage() (r float64, exists bool) {
	v := m.dosage
	if v == nil {
		return
	}
	return *v, true
}

// OldDosage returns the old "dosage" field's value of the Medicine entity.
// If the Medicine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicineMutation) OldDosage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDosage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDosage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDosage: %w", err)
	}
	return oldValue.Dosage, nil
}

// AddDosage adds f to the "dosage" field.
func (m *MedicineMutation) AddDosage(f float64) {
	if m.adddosage != nil {
		*m.adddosage += f
	} else {
		m.adddosage = &f
	}
}

// AddedDosage returns the value that was added to the "dosage" field in this mutation.
func (m *MedicineMutation) AddedDosage() (r float64, exists bool) {
	v := m.adddosage
	if v == nil {
		return
	}
	return *v, true
}

// ResetDosage resets all changes to the "dosage" field.
func (m *MedicineMutation) ResetDosage() {
	m.dosage = nil
	m.adddosage = nil
}

// SetUnit sets the "unit" field.
func (m *MedicineMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *MedicineMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the Medicine entity.
// If the Medicine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicineMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ResetUnit resets all changes to the "unit" field.
func (m *MedicineMutation) ResetUnit() {
	m.unit = nil
}

// SetAtc sets the "atc" field.
func (m *MedicineMutation) SetAtc(s string) {
	m.atc = &s
}

// Atc returns the value of the "atc" field in the mutation.
func (m *MedicineMutation) Atc() (r string, exists bool) {
	v := m.atc
	if v == nil {
		return
	}
	return *v, true
}

// OldAtc returns the old "atc" field's value of the Medicine entity.
// If the Medicine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicineMutation) OldAtc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAtc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAtc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAtc: %w", err)
	}
	return oldValue.Atc, nil
}

// ResetAtc resets all changes to the "atc" field.
func (m *MedicineMutation) ResetAtc() {
	m.atc = nil
}

// SetPackage sets the "package" field.
func (m *MedicineMutation) SetPackage(s string) {
	m._package = &s
}

// Package returns the value of the "package" field in the mutation.
func (m *MedicineMutation) Package() (r string, exists bool) {
	v := m._package
	if v == nil {
		return
	}
	return *v, true
}

// OldPackage returns the old "package" field's value of the Medicine entity.
// If the Medicine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicineMutation) OldPackage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackage: %w", err)
	}
	return oldValue.Package, nil
}

// ResetPackage resets all changes to the "package" field.
func (m *MedicineMutation) ResetPackage() {
	m._package = nil
}

// SetForm sets the "form" field.
func (m *MedicineMutation) SetForm(s string) {
	m.form = &s
}

// Form returns the value of the "form" field in the mutation.
func (m *MedicineMutation) Form() (r string, exists bool) {
	v := m.form
	if v == nil {
		return
	}
	return *v, true
}

// OldForm returns the old "form" field's value of the Medicine entity.
// If the Medicine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicineMutation) OldForm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForm: %w", err)
	}
	return oldValue.Form, nil
}

// ResetForm resets all changes to the "form" field.
func (m *MedicineMutation) ResetForm() {
	m.form = nil
}

// SetBoxSize sets the "box_size" field.
func (m *MedicineMutation) SetBoxSize(i int) {
	m.box_size = &i
	m.addbox_size = nil
}

// BoxSize returns the value of the "box_size" field in the mutation.
func (m *MedicineMutation) BoxSize() (r int, exists bool) {
	v := m.box_size
	if v == nil {
		return
	}
	return *v, true
}

// OldBoxSize returns the old "box_size" field's value of the Medicine entity.
// If the Medicine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicineMutation) OldBoxSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBoxSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBoxSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBoxSize: %w", err)
	}
	return oldValue.BoxSize, nil
}

// AddBoxSize adds i to the "box_size" field.
func (m *MedicineMutation) AddBoxSize(i int) {
	if m.addbox_size != nil {
		*m.addbox_size += i
	} else {
		m.addbox_size = &i
	}
}

// AddedBoxSize returns the value that was added to the "box_size" field in this mutation.
func (m *MedicineMutation) AddedBoxSize() (r int, exists bool) {
	v := m.addbox_size
	if v == nil {
		return
	}
	return *v, true
}

// ResetBoxSize resets all changes to the "box_size" field.
func (m *MedicineMutation) ResetBoxSize() {
	m.box_size = nil
	m.addbox_size = nil
}

// SetStock sets the "stock" field.
func (m *MedicineMutation) SetStock(f float32) {
	m.stock = &f
	m.addstock = nil
}

// Stock returns the value of the "stock" field in the mutation.
func (m *MedicineMutation) Stock() (r float32, exists bool) {
	v := m.stock
	if v == nil {
		return
	}
	return *v, true
}

// OldStock returns the old "stock" field's value of the Medicine entity.
// If the Medicine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicineMutation) OldStock(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStock: %w", err)
	}
	return oldValue.Stock, nil
}

// AddStock adds f to the "stock" field.
func (m *MedicineMutation) AddStock(f float32) {
	if m.addstock != nil {
		*m.addstock += f
	} else {
		m.addstock = &f
	}
}

// AddedStock returns the value that was added to the "stock" field in this mutation.
func (m *MedicineMutation) AddedStock() (r float32, exists bool) {
	v := m.addstock
	if v == nil {
		return
	}
	return *v, true
}

// ClearStock clears the value of the "stock" field.
func (m *MedicineMutation) ClearStock() {
	m.stock = nil
	m.addstock = nil
	m.clearedFields[medicine.FieldStock] = struct{}{}
}

// StockCleared returns if the "stock" field was cleared in this mutation.
func (m *MedicineMutation) StockCleared() bool {
	_, ok := m.clearedFields[medicine.FieldStock]
	return ok
}

// ResetStock resets all changes to the "stock" field.
func (m *MedicineMutation) ResetStock() {
	m.stock = nil
	m.addstock = nil
	delete(m.clearedFields, medicine.FieldStock)
}

// SetLastStockUpdate sets the "last_stock_update" field.
func (m *MedicineMutation) SetLastStockUpdate(t time.Time) {
	m.last_stock_update = &t
}

// LastStockUpdate returns the value of the "last_stock_update" field in the mutation.
func (m *MedicineMutation) LastStockUpdate() (r time.Time, exists bool) {
	v := m.last_stock_update
	if v == nil {
		return
	}
	return *v, true
}

// OldLastStockUpdate returns the old "last_stock_update" field's value of the Medicine entity.
// If the Medicine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicineMutation) OldLastStockUpdate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastStockUpdate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastStockUpdate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastStockUpdate: %w", err)
	}
	return oldValue.LastStockUpdate, nil
}

// ResetLastStockUpdate resets all changes to the "last_stock_update" field.
func (m *MedicineMutation) ResetLastStockUpdate() {
	m.last_stock_update = nil
}

// AddPurchaseIDs adds the "purchases" edge to the Purchase entity by ids.
func (m *MedicineMutation) AddPurchaseIDs(ids ...int) {
	if m.purchases == nil {
		m.purchases = make(map[int]struct{})
	}
	for i := range ids {
		m.purchases[ids[i]] = struct{}{}
	}
}

// ClearPurchases clears the "purchases" edge to the Purchase entity.
func (m *MedicineMutation) ClearPurchases() {
	m.clearedpurchases = true
}

// PurchasesCleared reports if the "purchases" edge to the Purchase entity was cleared.
func (m *MedicineMutation) PurchasesCleared() bool {
	return m.clearedpurchases
}

// RemovePurchaseIDs removes the "purchases" edge to the Purchase entity by IDs.
func (m *MedicineMutation) RemovePurchaseIDs(ids ...int) {
	if m.removedpurchases == nil {
		m.removedpurchases = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.purchases, ids[i])
		m.removedpurchases[ids[i]] = struct{}{}
	}
}

// RemovedPurchases returns the removed IDs of the "purchases" edge to the Purchase entity.
func (m *MedicineMutation) RemovedPurchasesIDs() (ids []int) {
	for id := range m.removedpurchases {
		ids = append(ids, id)
	}
	return
}

// PurchasesIDs returns the "purchases" edge IDs in the mutation.
func (m *MedicineMutation) PurchasesIDs() (ids []int) {
	for id := range m.purchases {
		ids = append(ids, id)
	}
	return
}

// ResetPurchases resets all changes to the "purchases" edge.
func (m *MedicineMutation) ResetPurchases() {
	m.purchases = nil
	m.clearedpurchases = false
	m.removedpurchases = nil
}

// AddStockingLogIDs adds the "stocking_logs" edge to the StockingLog entity by ids.
func (m *MedicineMutation) AddStockingLogIDs(ids ...int) {
	if m.stocking_logs == nil {
		m.stocking_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.stocking_logs[ids[i]] = struct{}{}
	}
}

// ClearStockingLogs clears the "stocking_logs" edge to the StockingLog entity.
func (m *MedicineMutation) ClearStockingLogs() {
	m.clearedstocking_logs = true
}

// StockingLogsCleared reports if the "stocking_logs" edge to the StockingLog entity was cleared.
func (m *MedicineMutation) StockingLogsCleared() bool {
	return m.clearedstocking_logs
}

// RemoveStockingLogIDs removes the "stocking_logs" edge to the StockingLog entity by IDs.
func (m *MedicineMutation) RemoveStockingLogIDs(ids ...int) {
	if m.removedstocking_logs == nil {
		m.removedstocking_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.stocking_logs, ids[i])
		m.removedstocking_logs[ids[i]] = struct{}{}
	}
}

// RemovedStockingLogs returns the removed IDs of the "stocking_logs" edge to the StockingLog entity.
func (m *MedicineMutation) RemovedStockingLogsIDs() (ids []int) {
	for id := range m.removedstocking_logs {
		ids = append(ids, id)
	}
	return
}

// StockingLogsIDs returns the "stocking_logs" edge IDs in the mutation.
func (m *MedicineMutation) StockingLogsIDs() (ids []int) {
	for id := range m.stocking_logs {
		ids = append(ids, id)
	}
	return
}

// ResetStockingLogs resets all changes to the "stocking_logs" edge.
func (m *MedicineMutation) ResetStockingLogs() {
	m.stocking_logs = nil
	m.clearedstocking_logs = false
	m.removedstocking_logs = nil
}

// SetActiveIngredientID sets the "active_ingredient" edge to the ActiveIngredient entity by id.
func (m *MedicineMutation) SetActiveIngredientID(id int) {
	m.active_ingredient = &id
}

// ClearActiveIngredient clears the "active_ingredient" edge to the ActiveIngredient entity.
func (m *MedicineMutation) ClearActiveIngredient() {
	m.clearedactive_ingredient = true
}

// ActiveIngredientCleared reports if the "active_ingredient" edge to the ActiveIngredient entity was cleared.
func (m *MedicineMutation) ActiveIngredientCleared() bool {
	return m.clearedactive_ingredient
}

// ActiveIngredientID returns the "active_ingredient" edge ID in the mutation.
func (m *MedicineMutation) ActiveIngredientID() (id int, exists bool) {
	if m.active_ingredient != nil {
		return *m.active_ingredient, true
	}
	return
}

// ActiveIngredientIDs returns the "active_ingredient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActiveIngredientID instead. It exists only for internal usage by the builders.
func (m *MedicineMutation) ActiveIngredientIDs() (ids []int) {
	if id := m.active_ingredient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActiveIngredient resets all changes to the "active_ingredient" edge.
func (m *MedicineMutation) ResetActiveIngredient() {
	m.active_ingredient = nil
	m.clearedactive_ingredient = false
}

// Where appends a list predicates to the MedicineMutation builder.
func (m *MedicineMutation) Where(ps ...predicate.Medicine) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MedicineMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MedicineMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Medicine, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MedicineMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MedicineMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Medicine).
func (m *MedicineMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MedicineMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, medicine.FieldName)
	}
	if m.mah != nil {
		fields = append(fields, medicine.FieldMah)
	}
	if m.dosage != nil {
		fields = append(fields, medicine.FieldDosage)
	}
	if m.unit != nil {
		fields = append(fields, medicine.FieldUnit)
	}
	if m.atc != nil {
		fields = append(fields, medicine.FieldAtc)
	}
	if m._package != nil {
		fields = append(fields, medicine.FieldPackage)
	}
	if m.form != nil {
		fields = append(fields, medicine.FieldForm)
	}
	if m.box_size != nil {
		fields = append(fields, medicine.FieldBoxSize)
	}
	if m.stock != nil {
		fields = append(fields, medicine.FieldStock)
	}
	if m.last_stock_update != nil {
		fields = append(fields, medicine.FieldLastStockUpdate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MedicineMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case medicine.FieldName:
		return m.Name()
	case medicine.FieldMah:
		return m.Mah()
	case medicine.FieldDosage:
		return m.Dosage()
	case medicine.FieldUnit:
		return m.Unit()
	case medicine.FieldAtc:
		return m.Atc()
	case medicine.FieldPackage:
		return m.Package()
	case medicine.FieldForm:
		return m.Form()
	case medicine.FieldBoxSize:
		return m.BoxSize()
	case medicine.FieldStock:
		return m.Stock()
	case medicine.FieldLastStockUpdate:
		return m.LastStockUpdate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MedicineMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case medicine.FieldName:
		return m.OldName(ctx)
	case medicine.FieldMah:
		return m.OldMah(ctx)
	case medicine.FieldDosage:
		return m.OldDosage(ctx)
	case medicine.FieldUnit:
		return m.OldUnit(ctx)
	case medicine.FieldAtc:
		return m.OldAtc(ctx)
	case medicine.FieldPackage:
		return m.OldPackage(ctx)
	case medicine.FieldForm:
		return m.OldForm(ctx)
	case medicine.FieldBoxSize:
		return m.OldBoxSize(ctx)
	case medicine.FieldStock:
		return m.OldStock(ctx)
	case medicine.FieldLastStockUpdate:
		return m.OldLastStockUpdate(ctx)
	}
	return nil, fmt.Errorf("unknown Medicine field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MedicineMutation) SetField(name string, value ent.Value) error {
	switch name {
	case medicine.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case medicine.FieldMah:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMah(v)
		return nil
	case medicine.FieldDosage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDosage(v)
		return nil
	case medicine.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case medicine.FieldAtc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAtc(v)
		return nil
	case medicine.FieldPackage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackage(v)
		return nil
	case medicine.FieldForm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForm(v)
		return nil
	case medicine.FieldBoxSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBoxSize(v)
		return nil
	case medicine.FieldStock:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStock(v)
		return nil
	case medicine.FieldLastStockUpdate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastStockUpdate(v)
		return nil
	}
	return fmt.Errorf("unknown Medicine field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MedicineMutation) AddedFields() []string {
	var fields []string
	if m.adddosage != nil {
		fields = append(fields, medicine.FieldDosage)
	}
	if m.addbox_size != nil {
		fields = append(fields, medicine.FieldBoxSize)
	}
	if m.addstock != nil {
		fields = append(fields, medicine.FieldStock)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MedicineMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case medicine.FieldDosage:
		return m.AddedDosage()
	case medicine.FieldBoxSize:
		return m.AddedBoxSize()
	case medicine.FieldStock:
		return m.AddedStock()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MedicineMutation) AddField(name string, value ent.Value) error {
	switch name {
	case medicine.FieldDosage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDosage(v)
		return nil
	case medicine.FieldBoxSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBoxSize(v)
		return nil
	case medicine.FieldStock:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStock(v)
		return nil
	}
	return fmt.Errorf("unknown Medicine numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MedicineMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(medicine.FieldStock) {
		fields = append(fields, medicine.FieldStock)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MedicineMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MedicineMutation) ClearField(name string) error {
	switch name {
	case medicine.FieldStock:
		m.ClearStock()
		return nil
	}
	return fmt.Errorf("unknown Medicine nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MedicineMutation) ResetField(name string) error {
	switch name {
	case medicine.FieldName:
		m.ResetName()
		return nil
	case medicine.FieldMah:
		m.ResetMah()
		return nil
	case medicine.FieldDosage:
		m.ResetDosage()
		return nil
	case medicine.FieldUnit:
		m.ResetUnit()
		return nil
	case medicine.FieldAtc:
		m.ResetAtc()
		return nil
	case medicine.FieldPackage:
		m.ResetPackage()
		return nil
	case medicine.FieldForm:
		m.ResetForm()
		return nil
	case medicine.FieldBoxSize:
		m.ResetBoxSize()
		return nil
	case medicine.FieldStock:
		m.ResetStock()
		return nil
	case medicine.FieldLastStockUpdate:
		m.ResetLastStockUpdate()
		return nil
	}
	return fmt.Errorf("unknown Medicine field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MedicineMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.purchases != nil {
		edges = append(edges, medicine.EdgePurchases)
	}
	if m.stocking_logs != nil {
		edges = append(edges, medicine.EdgeStockingLogs)
	}
	if m.active_ingredient != nil {
		edges = append(edges, medicine.EdgeActiveIngredient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MedicineMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case medicine.EdgePurchases:
		ids := make([]ent.Value, 0, len(m.purchases))
		for id := range m.purchases {
			ids = append(ids, id)
		}
		return ids
	case medicine.EdgeStockingLogs:
		ids := make([]ent.Value, 0, len(m.stocking_logs))
		for id := range m.stocking_logs {
			ids = append(ids, id)
		}
		return ids
	case medicine.EdgeActiveIngredient:
		if id := m.active_ingredient; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MedicineMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedpurchases != nil {
		edges = append(edges, medicine.EdgePurchases)
	}
	if m.removedstocking_logs != nil {
		edges = append(edges, medicine.EdgeStockingLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MedicineMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case medicine.EdgePurchases:
		ids := make([]ent.Value, 0, len(m.removedpurchases))
		for id := range m.removedpurchases {
			ids = append(ids, id)
		}
		return ids
	case medicine.EdgeStockingLogs:
		ids := make([]ent.Value, 0, len(m.removedstocking_logs))
		for id := range m.removedstocking_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MedicineMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpurchases {
		edges = append(edges, medicine.EdgePurchases)
	}
	if m.clearedstocking_logs {
		edges = append(edges, medicine.EdgeStockingLogs)
	}
	if m.clearedactive_ingredient {
		edges = append(edges, medicine.EdgeActiveIngredient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MedicineMutation) EdgeCleared(name string) bool {
	switch name {
	case medicine.EdgePurchases:
		return m.clearedpurchases
	case medicine.EdgeStockingLogs:
		return m.clearedstocking_logs
	case medicine.EdgeActiveIngredient:
		return m.clearedactive_ingredient
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MedicineMutation) ClearEdge(name string) error {
	switch name {
	case medicine.EdgeActiveIngredient:
		m.ClearActiveIngredient()
		return nil
	}
	return fmt.Errorf("unknown Medicine unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MedicineMutation) ResetEdge(name string) error {
	switch name {
	case medicine.EdgePurchases:
		m.ResetPurchases()
		return nil
	case medicine.EdgeStockingLogs:
		m.ResetStockingLogs()
		return nil
	case medicine.EdgeActiveIngredient:
		m.ResetActiveIngredient()
		return nil
	}
	return fmt.Errorf("unknown Medicine edge %s", name)
}

// PrescriptionMutation represents an operation that mutates the Prescription nodes in the graph.
type PrescriptionMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	dosage                   *int
	adddosage                *int
	unit                     *string
	dosage_frequency         *int
	adddosage_frequency      *int
	start_date               *time.Time
	end_date                 *time.Time
	clearedFields            map[string]struct{}
	comsumption_logs         map[int]struct{}
	removedcomsumption_logs  map[int]struct{}
	clearedcomsumption_logs  bool
	active_ingredient        *int
	clearedactive_ingredient bool
	done                     bool
	oldValue                 func(context.Context) (*Prescription, error)
	predicates               []predicate.Prescription
}

var _ ent.Mutation = (*PrescriptionMutation)(nil)

// prescriptionOption allows management of the mutation configuration using functional options.
type prescriptionOption func(*PrescriptionMutation)

// newPrescriptionMutation creates new mutation for the Prescription entity.
func newPrescriptionMutation(c config, op Op, opts ...prescriptionOption) *PrescriptionMutation {
	m := &PrescriptionMutation{
		config:        c,
		op:            op,
		typ:           TypePrescription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPrescriptionID sets the ID field of the mutation.
func withPrescriptionID(id int) prescriptionOption {
	return func(m *PrescriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *Prescription
		)
		m.oldValue = func(ctx context.Context) (*Prescription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Prescription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrescription sets the old Prescription of the mutation.
func withPrescription(node *Prescription) prescriptionOption {
	return func(m *PrescriptionMutation) {
		m.oldValue = func(context.Context) (*Prescription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PrescriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PrescriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PrescriptionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PrescriptionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Prescription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDosage sets the "dosage" field.
func (m *PrescriptionMutation) SetDosage(i int) {
	m.dosage = &i
	m.adddosage = nil
}

// Dosage returns the value of the "dosage" field in the mutation.
func (m *PrescriptionMutation) Dosage() (r int, exists bool) {
	v := m.dosage
	if v == nil {
		return
	}
	return *v, true
}

// OldDosage returns the old "dosage" field's value of the Prescription entity.
// If the Prescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrescriptionMutation) OldDosage(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDosage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDosage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDosage: %w", err)
	}
	return oldValue.Dosage, nil
}

// AddDosage adds i to the "dosage" field.
func (m *PrescriptionMutation) AddDosage(i int) {
	if m.adddosage != nil {
		*m.adddosage += i
	} else {
		m.adddosage = &i
	}
}

// AddedDosage returns the value that was added to the "dosage" field in this mutation.
func (m *PrescriptionMutation) AddedDosage() (r int, exists bool) {
	v := m.adddosage
	if v == nil {
		return
	}
	return *v, true
}

// ResetDosage resets all changes to the "dosage" field.
func (m *PrescriptionMutation) ResetDosage() {
	m.dosage = nil
	m.adddosage = nil
}

// SetUnit sets the "unit" field.
func (m *PrescriptionMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *PrescriptionMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the Prescription entity.
// If the Prescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrescriptionMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ResetUnit resets all changes to the "unit" field.
func (m *PrescriptionMutation) ResetUnit() {
	m.unit = nil
}

// SetDosageFrequency sets the "dosage_frequency" field.
func (m *PrescriptionMutation) SetDosageFrequency(i int) {
	m.dosage_frequency = &i
	m.adddosage_frequency = nil
}

// DosageFrequency returns the value of the "dosage_frequency" field in the mutation.
func (m *PrescriptionMutation) DosageFrequency() (r int, exists bool) {
	v := m.dosage_frequency
	if v == nil {
		return
	}
	return *v, true
}

// OldDosageFrequency returns the old "dosage_frequency" field's value of the Prescription entity.
// If the Prescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrescriptionMutation) OldDosageFrequency(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDosageFrequency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDosageFrequency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDosageFrequency: %w", err)
	}
	return oldValue.DosageFrequency, nil
}

// AddDosageFrequency adds i to the "dosage_frequency" field.
func (m *PrescriptionMutation) AddDosageFrequency(i int) {
	if m.adddosage_frequency != nil {
		*m.adddosage_frequency += i
	} else {
		m.adddosage_frequency = &i
	}
}

// AddedDosageFrequency returns the value that was added to the "dosage_frequency" field in this mutation.
func (m *PrescriptionMutation) AddedDosageFrequency() (r int, exists bool) {
	v := m.adddosage_frequency
	if v == nil {
		return
	}
	return *v, true
}

// ClearDosageFrequency clears the value of the "dosage_frequency" field.
func (m *PrescriptionMutation) ClearDosageFrequency() {
	m.dosage_frequency = nil
	m.adddosage_frequency = nil
	m.clearedFields[prescription.FieldDosageFrequency] = struct{}{}
}

// DosageFrequencyCleared returns if the "dosage_frequency" field was cleared in this mutation.
func (m *PrescriptionMutation) DosageFrequencyCleared() bool {
	_, ok := m.clearedFields[prescription.FieldDosageFrequency]
	return ok
}

// ResetDosageFrequency resets all changes to the "dosage_frequency" field.
func (m *PrescriptionMutation) ResetDosageFrequency() {
	m.dosage_frequency = nil
	m.adddosage_frequency = nil
	delete(m.clearedFields, prescription.FieldDosageFrequency)
}

// SetStartDate sets the "start_date" field.
func (m *PrescriptionMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *PrescriptionMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Prescription entity.
// If the Prescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrescriptionMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *PrescriptionMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[prescription.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *PrescriptionMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[prescription.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *PrescriptionMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, prescription.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *PrescriptionMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *PrescriptionMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Prescription entity.
// If the Prescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrescriptionMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *PrescriptionMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[prescription.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *PrescriptionMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[prescription.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *PrescriptionMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, prescription.FieldEndDate)
}

// AddComsumptionLogIDs adds the "comsumption_logs" edge to the ConsumptionLog entity by ids.
func (m *PrescriptionMutation) AddComsumptionLogIDs(ids ...int) {
	if m.comsumption_logs == nil {
		m.comsumption_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.comsumption_logs[ids[i]] = struct{}{}
	}
}

// ClearComsumptionLogs clears the "comsumption_logs" edge to the ConsumptionLog entity.
func (m *PrescriptionMutation) ClearComsumptionLogs() {
	m.clearedcomsumption_logs = true
}

// ComsumptionLogsCleared reports if the "comsumption_logs" edge to the ConsumptionLog entity was cleared.
func (m *PrescriptionMutation) ComsumptionLogsCleared() bool {
	return m.clearedcomsumption_logs
}

// RemoveComsumptionLogIDs removes the "comsumption_logs" edge to the ConsumptionLog entity by IDs.
func (m *PrescriptionMutation) RemoveComsumptionLogIDs(ids ...int) {
	if m.removedcomsumption_logs == nil {
		m.removedcomsumption_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.comsumption_logs, ids[i])
		m.removedcomsumption_logs[ids[i]] = struct{}{}
	}
}

// RemovedComsumptionLogs returns the removed IDs of the "comsumption_logs" edge to the ConsumptionLog entity.
func (m *PrescriptionMutation) RemovedComsumptionLogsIDs() (ids []int) {
	for id := range m.removedcomsumption_logs {
		ids = append(ids, id)
	}
	return
}

// ComsumptionLogsIDs returns the "comsumption_logs" edge IDs in the mutation.
func (m *PrescriptionMutation) ComsumptionLogsIDs() (ids []int) {
	for id := range m.comsumption_logs {
		ids = append(ids, id)
	}
	return
}

// ResetComsumptionLogs resets all changes to the "comsumption_logs" edge.
func (m *PrescriptionMutation) ResetComsumptionLogs() {
	m.comsumption_logs = nil
	m.clearedcomsumption_logs = false
	m.removedcomsumption_logs = nil
}

// SetActiveIngredientID sets the "active_ingredient" edge to the ActiveIngredient entity by id.
func (m *PrescriptionMutation) SetActiveIngredientID(id int) {
	m.active_ingredient = &id
}

// ClearActiveIngredient clears the "active_ingredient" edge to the ActiveIngredient entity.
func (m *PrescriptionMutation) ClearActiveIngredient() {
	m.clearedactive_ingredient = true
}

// ActiveIngredientCleared reports if the "active_ingredient" edge to the ActiveIngredient entity was cleared.
func (m *PrescriptionMutation) ActiveIngredientCleared() bool {
	return m.clearedactive_ingredient
}

// ActiveIngredientID returns the "active_ingredient" edge ID in the mutation.
func (m *PrescriptionMutation) ActiveIngredientID() (id int, exists bool) {
	if m.active_ingredient != nil {
		return *m.active_ingredient, true
	}
	return
}

// ActiveIngredientIDs returns the "active_ingredient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActiveIngredientID instead. It exists only for internal usage by the builders.
func (m *PrescriptionMutation) ActiveIngredientIDs() (ids []int) {
	if id := m.active_ingredient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActiveIngredient resets all changes to the "active_ingredient" edge.
func (m *PrescriptionMutation) ResetActiveIngredient() {
	m.active_ingredient = nil
	m.clearedactive_ingredient = false
}

// Where appends a list predicates to the PrescriptionMutation builder.
func (m *PrescriptionMutation) Where(ps ...predicate.Prescription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PrescriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PrescriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Prescription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PrescriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PrescriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Prescription).
func (m *PrescriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PrescriptionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.dosage != nil {
		fields = append(fields, prescription.FieldDosage)
	}
	if m.unit != nil {
		fields = append(fields, prescription.FieldUnit)
	}
	if m.dosage_frequency != nil {
		fields = append(fields, prescription.FieldDosageFrequency)
	}
	if m.start_date != nil {
		fields = append(fields, prescription.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, prescription.FieldEndDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PrescriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prescription.FieldDosage:
		return m.Dosage()
	case prescription.FieldUnit:
		return m.Unit()
	case prescription.FieldDosageFrequency:
		return m.DosageFrequency()
	case prescription.FieldStartDate:
		return m.StartDate()
	case prescription.FieldEndDate:
		return m.EndDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PrescriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prescription.FieldDosage:
		return m.OldDosage(ctx)
	case prescription.FieldUnit:
		return m.OldUnit(ctx)
	case prescription.FieldDosageFrequency:
		return m.OldDosageFrequency(ctx)
	case prescription.FieldStartDate:
		return m.OldStartDate(ctx)
	case prescription.FieldEndDate:
		return m.OldEndDate(ctx)
	}
	return nil, fmt.Errorf("unknown Prescription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrescriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prescription.FieldDosage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDosage(v)
		return nil
	case prescription.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case prescription.FieldDosageFrequency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDosageFrequency(v)
		return nil
	case prescription.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case prescription.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	}
	return fmt.Errorf("unknown Prescription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PrescriptionMutation) AddedFields() []string {
	var fields []string
	if m.adddosage != nil {
		fields = append(fields, prescription.FieldDosage)
	}
	if m.adddosage_frequency != nil {
		fields = append(fields, prescription.FieldDosageFrequency)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PrescriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case prescription.FieldDosage:
		return m.AddedDosage()
	case prescription.FieldDosageFrequency:
		return m.AddedDosageFrequency()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrescriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case prescription.FieldDosage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDosage(v)
		return nil
	case prescription.FieldDosageFrequency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDosageFrequency(v)
		return nil
	}
	return fmt.Errorf("unknown Prescription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PrescriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(prescription.FieldDosageFrequency) {
		fields = append(fields, prescription.FieldDosageFrequency)
	}
	if m.FieldCleared(prescription.FieldStartDate) {
		fields = append(fields, prescription.FieldStartDate)
	}
	if m.FieldCleared(prescription.FieldEndDate) {
		fields = append(fields, prescription.FieldEndDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PrescriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PrescriptionMutation) ClearField(name string) error {
	switch name {
	case prescription.FieldDosageFrequency:
		m.ClearDosageFrequency()
		return nil
	case prescription.FieldStartDate:
		m.ClearStartDate()
		return nil
	case prescription.FieldEndDate:
		m.ClearEndDate()
		return nil
	}
	return fmt.Errorf("unknown Prescription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PrescriptionMutation) ResetField(name string) error {
	switch name {
	case prescription.FieldDosage:
		m.ResetDosage()
		return nil
	case prescription.FieldUnit:
		m.ResetUnit()
		return nil
	case prescription.FieldDosageFrequency:
		m.ResetDosageFrequency()
		return nil
	case prescription.FieldStartDate:
		m.ResetStartDate()
		return nil
	case prescription.FieldEndDate:
		m.ResetEndDate()
		return nil
	}
	return fmt.Errorf("unknown Prescription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PrescriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.comsumption_logs != nil {
		edges = append(edges, prescription.EdgeComsumptionLogs)
	}
	if m.active_ingredient != nil {
		edges = append(edges, prescription.EdgeActiveIngredient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PrescriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prescription.EdgeComsumptionLogs:
		ids := make([]ent.Value, 0, len(m.comsumption_logs))
		for id := range m.comsumption_logs {
			ids = append(ids, id)
		}
		return ids
	case prescription.EdgeActiveIngredient:
		if id := m.active_ingredient; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PrescriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcomsumption_logs != nil {
		edges = append(edges, prescription.EdgeComsumptionLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PrescriptionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case prescription.EdgeComsumptionLogs:
		ids := make([]ent.Value, 0, len(m.removedcomsumption_logs))
		for id := range m.removedcomsumption_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PrescriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcomsumption_logs {
		edges = append(edges, prescription.EdgeComsumptionLogs)
	}
	if m.clearedactive_ingredient {
		edges = append(edges, prescription.EdgeActiveIngredient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PrescriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case prescription.EdgeComsumptionLogs:
		return m.clearedcomsumption_logs
	case prescription.EdgeActiveIngredient:
		return m.clearedactive_ingredient
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PrescriptionMutation) ClearEdge(name string) error {
	switch name {
	case prescription.EdgeActiveIngredient:
		m.ClearActiveIngredient()
		return nil
	}
	return fmt.Errorf("unknown Prescription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PrescriptionMutation) ResetEdge(name string) error {
	switch name {
	case prescription.EdgeComsumptionLogs:
		m.ResetComsumptionLogs()
		return nil
	case prescription.EdgeActiveIngredient:
		m.ResetActiveIngredient()
		return nil
	}
	return fmt.Errorf("unknown Prescription edge %s", name)
}

// PurchaseMutation represents an operation that mutates the Purchase nodes in the graph.
type PurchaseMutation struct {
	config
	op            Op
	typ           string
	id            *int
	puchased_at   *time.Time
	quantity      *int
	addquantity   *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Purchase, error)
	predicates    []predicate.Purchase
}

var _ ent.Mutation = (*PurchaseMutation)(nil)

// purchaseOption allows management of the mutation configuration using functional options.
type purchaseOption func(*PurchaseMutation)

// newPurchaseMutation creates new mutation for the Purchase entity.
func newPurchaseMutation(c config, op Op, opts ...purchaseOption) *PurchaseMutation {
	m := &PurchaseMutation{
		config:        c,
		op:            op,
		typ:           TypePurchase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPurchaseID sets the ID field of the mutation.
func withPurchaseID(id int) purchaseOption {
	return func(m *PurchaseMutation) {
		var (
			err   error
			once  sync.Once
			value *Purchase
		)
		m.oldValue = func(ctx context.Context) (*Purchase, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Purchase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPurchase sets the old Purchase of the mutation.
func withPurchase(node *Purchase) purchaseOption {
	return func(m *PurchaseMutation) {
		m.oldValue = func(context.Context) (*Purchase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PurchaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PurchaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PurchaseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PurchaseMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Purchase.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPuchasedAt sets the "puchased_at" field.
func (m *PurchaseMutation) SetPuchasedAt(t time.Time) {
	m.puchased_at = &t
}

// PuchasedAt returns the value of the "puchased_at" field in the mutation.
func (m *PurchaseMutation) PuchasedAt() (r time.Time, exists bool) {
	v := m.puchased_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPuchasedAt returns the old "puchased_at" field's value of the Purchase entity.
// If the Purchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PurchaseMutation) OldPuchasedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPuchasedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPuchasedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPuchasedAt: %w", err)
	}
	return oldValue.PuchasedAt, nil
}

// ResetPuchasedAt resets all changes to the "puchased_at" field.
func (m *PurchaseMutation) ResetPuchasedAt() {
	m.puchased_at = nil
}

// SetQuantity sets the "quantity" field.
func (m *PurchaseMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *PurchaseMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the Purchase entity.
// If the Purchase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PurchaseMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *PurchaseMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *PurchaseMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *PurchaseMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// Where appends a list predicates to the PurchaseMutation builder.
func (m *PurchaseMutation) Where(ps ...predicate.Purchase) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PurchaseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PurchaseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Purchase, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PurchaseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PurchaseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Purchase).
func (m *PurchaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PurchaseMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.puchased_at != nil {
		fields = append(fields, purchase.FieldPuchasedAt)
	}
	if m.quantity != nil {
		fields = append(fields, purchase.FieldQuantity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PurchaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case purchase.FieldPuchasedAt:
		return m.PuchasedAt()
	case purchase.FieldQuantity:
		return m.Quantity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PurchaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case purchase.FieldPuchasedAt:
		return m.OldPuchasedAt(ctx)
	case purchase.FieldQuantity:
		return m.OldQuantity(ctx)
	}
	return nil, fmt.Errorf("unknown Purchase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PurchaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case purchase.FieldPuchasedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPuchasedAt(v)
		return nil
	case purchase.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown Purchase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PurchaseMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, purchase.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PurchaseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case purchase.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PurchaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case purchase.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown Purchase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PurchaseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PurchaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PurchaseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Purchase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PurchaseMutation) ResetField(name string) error {
	switch name {
	case purchase.FieldPuchasedAt:
		m.ResetPuchasedAt()
		return nil
	case purchase.FieldQuantity:
		m.ResetQuantity()
		return nil
	}
	return fmt.Errorf("unknown Purchase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PurchaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PurchaseMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PurchaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PurchaseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PurchaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PurchaseMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PurchaseMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Purchase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PurchaseMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Purchase edge %s", name)
}

// StockingLogMutation represents an operation that mutates the StockingLog nodes in the graph.
type StockingLogMutation struct {
	config
	op              Op
	typ             string
	id              *int
	stocked_at      *time.Time
	quantity        *int
	addquantity     *int
	clearedFields   map[string]struct{}
	medicine        *int
	clearedmedicine bool
	done            bool
	oldValue        func(context.Context) (*StockingLog, error)
	predicates      []predicate.StockingLog
}

var _ ent.Mutation = (*StockingLogMutation)(nil)

// stockinglogOption allows management of the mutation configuration using functional options.
type stockinglogOption func(*StockingLogMutation)

// newStockingLogMutation creates new mutation for the StockingLog entity.
func newStockingLogMutation(c config, op Op, opts ...stockinglogOption) *StockingLogMutation {
	m := &StockingLogMutation{
		config:        c,
		op:            op,
		typ:           TypeStockingLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStockingLogID sets the ID field of the mutation.
func withStockingLogID(id int) stockinglogOption {
	return func(m *StockingLogMutation) {
		var (
			err   error
			once  sync.Once
			value *StockingLog
		)
		m.oldValue = func(ctx context.Context) (*StockingLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StockingLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStockingLog sets the old StockingLog of the mutation.
func withStockingLog(node *StockingLog) stockinglogOption {
	return func(m *StockingLogMutation) {
		m.oldValue = func(context.Context) (*StockingLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StockingLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StockingLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StockingLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StockingLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StockingLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStockedAt sets the "stocked_at" field.
func (m *StockingLogMutation) SetStockedAt(t time.Time) {
	m.stocked_at = &t
}

// StockedAt returns the value of the "stocked_at" field in the mutation.
func (m *StockingLogMutation) StockedAt() (r time.Time, exists bool) {
	v := m.stocked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStockedAt returns the old "stocked_at" field's value of the StockingLog entity.
// If the StockingLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockingLogMutation) OldStockedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStockedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStockedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStockedAt: %w", err)
	}
	return oldValue.StockedAt, nil
}

// ResetStockedAt resets all changes to the "stocked_at" field.
func (m *StockingLogMutation) ResetStockedAt() {
	m.stocked_at = nil
}

// SetQuantity sets the "quantity" field.
func (m *StockingLogMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *StockingLogMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the StockingLog entity.
// If the StockingLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockingLogMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *StockingLogMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *StockingLogMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *StockingLogMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetMedicineID sets the "medicine" edge to the Medicine entity by id.
func (m *StockingLogMutation) SetMedicineID(id int) {
	m.medicine = &id
}

// ClearMedicine clears the "medicine" edge to the Medicine entity.
func (m *StockingLogMutation) ClearMedicine() {
	m.clearedmedicine = true
}

// MedicineCleared reports if the "medicine" edge to the Medicine entity was cleared.
func (m *StockingLogMutation) MedicineCleared() bool {
	return m.clearedmedicine
}

// MedicineID returns the "medicine" edge ID in the mutation.
func (m *StockingLogMutation) MedicineID() (id int, exists bool) {
	if m.medicine != nil {
		return *m.medicine, true
	}
	return
}

// MedicineIDs returns the "medicine" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MedicineID instead. It exists only for internal usage by the builders.
func (m *StockingLogMutation) MedicineIDs() (ids []int) {
	if id := m.medicine; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMedicine resets all changes to the "medicine" edge.
func (m *StockingLogMutation) ResetMedicine() {
	m.medicine = nil
	m.clearedmedicine = false
}

// Where appends a list predicates to the StockingLogMutation builder.
func (m *StockingLogMutation) Where(ps ...predicate.StockingLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StockingLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StockingLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StockingLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StockingLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StockingLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StockingLog).
func (m *StockingLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StockingLogMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.stocked_at != nil {
		fields = append(fields, stockinglog.FieldStockedAt)
	}
	if m.quantity != nil {
		fields = append(fields, stockinglog.FieldQuantity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StockingLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stockinglog.FieldStockedAt:
		return m.StockedAt()
	case stockinglog.FieldQuantity:
		return m.Quantity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StockingLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stockinglog.FieldStockedAt:
		return m.OldStockedAt(ctx)
	case stockinglog.FieldQuantity:
		return m.OldQuantity(ctx)
	}
	return nil, fmt.Errorf("unknown StockingLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockingLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stockinglog.FieldStockedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStockedAt(v)
		return nil
	case stockinglog.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown StockingLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StockingLogMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, stockinglog.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StockingLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case stockinglog.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockingLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case stockinglog.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown StockingLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StockingLogMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StockingLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StockingLogMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StockingLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StockingLogMutation) ResetField(name string) error {
	switch name {
	case stockinglog.FieldStockedAt:
		m.ResetStockedAt()
		return nil
	case stockinglog.FieldQuantity:
		m.ResetQuantity()
		return nil
	}
	return fmt.Errorf("unknown StockingLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StockingLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.medicine != nil {
		edges = append(edges, stockinglog.EdgeMedicine)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StockingLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case stockinglog.EdgeMedicine:
		if id := m.medicine; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StockingLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StockingLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StockingLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmedicine {
		edges = append(edges, stockinglog.EdgeMedicine)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StockingLogMutation) EdgeCleared(name string) bool {
	switch name {
	case stockinglog.EdgeMedicine:
		return m.clearedmedicine
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StockingLogMutation) ClearEdge(name string) error {
	switch name {
	case stockinglog.EdgeMedicine:
		m.ClearMedicine()
		return nil
	}
	return fmt.Errorf("unknown StockingLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StockingLogMutation) ResetEdge(name string) error {
	switch name {
	case stockinglog.EdgeMedicine:
		m.ResetMedicine()
		return nil
	}
	return fmt.Errorf("unknown StockingLog edge %s", name)
}
