// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"fstiffo/pills/ent/activeingredient"
	"fstiffo/pills/ent/consumptionlog"
	"fstiffo/pills/ent/medicine"
	"fstiffo/pills/ent/predicate"
	"fstiffo/pills/ent/prescription"
	"fstiffo/pills/ent/stockinglog"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeActiveIngredient = "ActiveIngredient"
	TypeConsumptionLog   = "ConsumptionLog"
	TypeMedicine         = "Medicine"
	TypePrescription     = "Prescription"
	TypeStockingLog      = "StockingLog"
)

// ActiveIngredientMutation represents an operation that mutates the ActiveIngredient nodes in the graph.
type ActiveIngredientMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	name                    *string
	stock                   *int
	addstock                *int
	unit                    *activeingredient.Unit
	last_stocked_at         *time.Time
	last_consumed_at        *time.Time
	clearedFields           map[string]struct{}
	medicines               map[int]struct{}
	removedmedicines        map[int]struct{}
	clearedmedicines        bool
	prescriptions           map[int]struct{}
	removedprescriptions    map[int]struct{}
	clearedprescriptions    bool
	stocking_logs           map[int]struct{}
	removedstocking_logs    map[int]struct{}
	clearedstocking_logs    bool
	consumption_logs        map[int]struct{}
	removedconsumption_logs map[int]struct{}
	clearedconsumption_logs bool
	done                    bool
	oldValue                func(context.Context) (*ActiveIngredient, error)
	predicates              []predicate.ActiveIngredient
}

var _ ent.Mutation = (*ActiveIngredientMutation)(nil)

// activeingredientOption allows management of the mutation configuration using functional options.
type activeingredientOption func(*ActiveIngredientMutation)

// newActiveIngredientMutation creates new mutation for the ActiveIngredient entity.
func newActiveIngredientMutation(c config, op Op, opts ...activeingredientOption) *ActiveIngredientMutation {
	m := &ActiveIngredientMutation{
		config:        c,
		op:            op,
		typ:           TypeActiveIngredient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActiveIngredientID sets the ID field of the mutation.
func withActiveIngredientID(id int) activeingredientOption {
	return func(m *ActiveIngredientMutation) {
		var (
			err   error
			once  sync.Once
			value *ActiveIngredient
		)
		m.oldValue = func(ctx context.Context) (*ActiveIngredient, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActiveIngredient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActiveIngredient sets the old ActiveIngredient of the mutation.
func withActiveIngredient(node *ActiveIngredient) activeingredientOption {
	return func(m *ActiveIngredientMutation) {
		m.oldValue = func(context.Context) (*ActiveIngredient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActiveIngredientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActiveIngredientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActiveIngredientMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActiveIngredientMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActiveIngredient.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ActiveIngredientMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ActiveIngredientMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ActiveIngredient entity.
// If the ActiveIngredient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActiveIngredientMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ActiveIngredientMutation) ResetName() {
	m.name = nil
}

// SetStock sets the "stock" field.
func (m *ActiveIngredientMutation) SetStock(i int) {
	m.stock = &i
	m.addstock = nil
}

// Stock returns the value of the "stock" field in the mutation.
func (m *ActiveIngredientMutation) Stock() (r int, exists bool) {
	v := m.stock
	if v == nil {
		return
	}
	return *v, true
}

// OldStock returns the old "stock" field's value of the ActiveIngredient entity.
// If the ActiveIngredient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActiveIngredientMutation) OldStock(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStock: %w", err)
	}
	return oldValue.Stock, nil
}

// AddStock adds i to the "stock" field.
func (m *ActiveIngredientMutation) AddStock(i int) {
	if m.addstock != nil {
		*m.addstock += i
	} else {
		m.addstock = &i
	}
}

// AddedStock returns the value that was added to the "stock" field in this mutation.
func (m *ActiveIngredientMutation) AddedStock() (r int, exists bool) {
	v := m.addstock
	if v == nil {
		return
	}
	return *v, true
}

// ClearStock clears the value of the "stock" field.
func (m *ActiveIngredientMutation) ClearStock() {
	m.stock = nil
	m.addstock = nil
	m.clearedFields[activeingredient.FieldStock] = struct{}{}
}

// StockCleared returns if the "stock" field was cleared in this mutation.
func (m *ActiveIngredientMutation) StockCleared() bool {
	_, ok := m.clearedFields[activeingredient.FieldStock]
	return ok
}

// ResetStock resets all changes to the "stock" field.
func (m *ActiveIngredientMutation) ResetStock() {
	m.stock = nil
	m.addstock = nil
	delete(m.clearedFields, activeingredient.FieldStock)
}

// SetUnit sets the "unit" field.
func (m *ActiveIngredientMutation) SetUnit(a activeingredient.Unit) {
	m.unit = &a
}

// Unit returns the value of the "unit" field in the mutation.
func (m *ActiveIngredientMutation) Unit() (r activeingredient.Unit, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the ActiveIngredient entity.
// If the ActiveIngredient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActiveIngredientMutation) OldUnit(ctx context.Context) (v activeingredient.Unit, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ClearUnit clears the value of the "unit" field.
func (m *ActiveIngredientMutation) ClearUnit() {
	m.unit = nil
	m.clearedFields[activeingredient.FieldUnit] = struct{}{}
}

// UnitCleared returns if the "unit" field was cleared in this mutation.
func (m *ActiveIngredientMutation) UnitCleared() bool {
	_, ok := m.clearedFields[activeingredient.FieldUnit]
	return ok
}

// ResetUnit resets all changes to the "unit" field.
func (m *ActiveIngredientMutation) ResetUnit() {
	m.unit = nil
	delete(m.clearedFields, activeingredient.FieldUnit)
}

// SetLastStockedAt sets the "last_stocked_at" field.
func (m *ActiveIngredientMutation) SetLastStockedAt(t time.Time) {
	m.last_stocked_at = &t
}

// LastStockedAt returns the value of the "last_stocked_at" field in the mutation.
func (m *ActiveIngredientMutation) LastStockedAt() (r time.Time, exists bool) {
	v := m.last_stocked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastStockedAt returns the old "last_stocked_at" field's value of the ActiveIngredient entity.
// If the ActiveIngredient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActiveIngredientMutation) OldLastStockedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastStockedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastStockedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastStockedAt: %w", err)
	}
	return oldValue.LastStockedAt, nil
}

// ResetLastStockedAt resets all changes to the "last_stocked_at" field.
func (m *ActiveIngredientMutation) ResetLastStockedAt() {
	m.last_stocked_at = nil
}

// SetLastConsumedAt sets the "last_consumed_at" field.
func (m *ActiveIngredientMutation) SetLastConsumedAt(t time.Time) {
	m.last_consumed_at = &t
}

// LastConsumedAt returns the value of the "last_consumed_at" field in the mutation.
func (m *ActiveIngredientMutation) LastConsumedAt() (r time.Time, exists bool) {
	v := m.last_consumed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastConsumedAt returns the old "last_consumed_at" field's value of the ActiveIngredient entity.
// If the ActiveIngredient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActiveIngredientMutation) OldLastConsumedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastConsumedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastConsumedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastConsumedAt: %w", err)
	}
	return oldValue.LastConsumedAt, nil
}

// ResetLastConsumedAt resets all changes to the "last_consumed_at" field.
func (m *ActiveIngredientMutation) ResetLastConsumedAt() {
	m.last_consumed_at = nil
}

// AddMedicineIDs adds the "medicines" edge to the Medicine entity by ids.
func (m *ActiveIngredientMutation) AddMedicineIDs(ids ...int) {
	if m.medicines == nil {
		m.medicines = make(map[int]struct{})
	}
	for i := range ids {
		m.medicines[ids[i]] = struct{}{}
	}
}

// ClearMedicines clears the "medicines" edge to the Medicine entity.
func (m *ActiveIngredientMutation) ClearMedicines() {
	m.clearedmedicines = true
}

// MedicinesCleared reports if the "medicines" edge to the Medicine entity was cleared.
func (m *ActiveIngredientMutation) MedicinesCleared() bool {
	return m.clearedmedicines
}

// RemoveMedicineIDs removes the "medicines" edge to the Medicine entity by IDs.
func (m *ActiveIngredientMutation) RemoveMedicineIDs(ids ...int) {
	if m.removedmedicines == nil {
		m.removedmedicines = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.medicines, ids[i])
		m.removedmedicines[ids[i]] = struct{}{}
	}
}

// RemovedMedicines returns the removed IDs of the "medicines" edge to the Medicine entity.
func (m *ActiveIngredientMutation) RemovedMedicinesIDs() (ids []int) {
	for id := range m.removedmedicines {
		ids = append(ids, id)
	}
	return
}

// MedicinesIDs returns the "medicines" edge IDs in the mutation.
func (m *ActiveIngredientMutation) MedicinesIDs() (ids []int) {
	for id := range m.medicines {
		ids = append(ids, id)
	}
	return
}

// ResetMedicines resets all changes to the "medicines" edge.
func (m *ActiveIngredientMutation) ResetMedicines() {
	m.medicines = nil
	m.clearedmedicines = false
	m.removedmedicines = nil
}

// AddPrescriptionIDs adds the "prescriptions" edge to the Prescription entity by ids.
func (m *ActiveIngredientMutation) AddPrescriptionIDs(ids ...int) {
	if m.prescriptions == nil {
		m.prescriptions = make(map[int]struct{})
	}
	for i := range ids {
		m.prescriptions[ids[i]] = struct{}{}
	}
}

// ClearPrescriptions clears the "prescriptions" edge to the Prescription entity.
func (m *ActiveIngredientMutation) ClearPrescriptions() {
	m.clearedprescriptions = true
}

// PrescriptionsCleared reports if the "prescriptions" edge to the Prescription entity was cleared.
func (m *ActiveIngredientMutation) PrescriptionsCleared() bool {
	return m.clearedprescriptions
}

// RemovePrescriptionIDs removes the "prescriptions" edge to the Prescription entity by IDs.
func (m *ActiveIngredientMutation) RemovePrescriptionIDs(ids ...int) {
	if m.removedprescriptions == nil {
		m.removedprescriptions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.prescriptions, ids[i])
		m.removedprescriptions[ids[i]] = struct{}{}
	}
}

// RemovedPrescriptions returns the removed IDs of the "prescriptions" edge to the Prescription entity.
func (m *ActiveIngredientMutation) RemovedPrescriptionsIDs() (ids []int) {
	for id := range m.removedprescriptions {
		ids = append(ids, id)
	}
	return
}

// PrescriptionsIDs returns the "prescriptions" edge IDs in the mutation.
func (m *ActiveIngredientMutation) PrescriptionsIDs() (ids []int) {
	for id := range m.prescriptions {
		ids = append(ids, id)
	}
	return
}

// ResetPrescriptions resets all changes to the "prescriptions" edge.
func (m *ActiveIngredientMutation) ResetPrescriptions() {
	m.prescriptions = nil
	m.clearedprescriptions = false
	m.removedprescriptions = nil
}

// AddStockingLogIDs adds the "stocking_logs" edge to the StockingLog entity by ids.
func (m *ActiveIngredientMutation) AddStockingLogIDs(ids ...int) {
	if m.stocking_logs == nil {
		m.stocking_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.stocking_logs[ids[i]] = struct{}{}
	}
}

// ClearStockingLogs clears the "stocking_logs" edge to the StockingLog entity.
func (m *ActiveIngredientMutation) ClearStockingLogs() {
	m.clearedstocking_logs = true
}

// StockingLogsCleared reports if the "stocking_logs" edge to the StockingLog entity was cleared.
func (m *ActiveIngredientMutation) StockingLogsCleared() bool {
	return m.clearedstocking_logs
}

// RemoveStockingLogIDs removes the "stocking_logs" edge to the StockingLog entity by IDs.
func (m *ActiveIngredientMutation) RemoveStockingLogIDs(ids ...int) {
	if m.removedstocking_logs == nil {
		m.removedstocking_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.stocking_logs, ids[i])
		m.removedstocking_logs[ids[i]] = struct{}{}
	}
}

// RemovedStockingLogs returns the removed IDs of the "stocking_logs" edge to the StockingLog entity.
func (m *ActiveIngredientMutation) RemovedStockingLogsIDs() (ids []int) {
	for id := range m.removedstocking_logs {
		ids = append(ids, id)
	}
	return
}

// StockingLogsIDs returns the "stocking_logs" edge IDs in the mutation.
func (m *ActiveIngredientMutation) StockingLogsIDs() (ids []int) {
	for id := range m.stocking_logs {
		ids = append(ids, id)
	}
	return
}

// ResetStockingLogs resets all changes to the "stocking_logs" edge.
func (m *ActiveIngredientMutation) ResetStockingLogs() {
	m.stocking_logs = nil
	m.clearedstocking_logs = false
	m.removedstocking_logs = nil
}

// AddConsumptionLogIDs adds the "consumption_logs" edge to the ConsumptionLog entity by ids.
func (m *ActiveIngredientMutation) AddConsumptionLogIDs(ids ...int) {
	if m.consumption_logs == nil {
		m.consumption_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.consumption_logs[ids[i]] = struct{}{}
	}
}

// ClearConsumptionLogs clears the "consumption_logs" edge to the ConsumptionLog entity.
func (m *ActiveIngredientMutation) ClearConsumptionLogs() {
	m.clearedconsumption_logs = true
}

// ConsumptionLogsCleared reports if the "consumption_logs" edge to the ConsumptionLog entity was cleared.
func (m *ActiveIngredientMutation) ConsumptionLogsCleared() bool {
	return m.clearedconsumption_logs
}

// RemoveConsumptionLogIDs removes the "consumption_logs" edge to the ConsumptionLog entity by IDs.
func (m *ActiveIngredientMutation) RemoveConsumptionLogIDs(ids ...int) {
	if m.removedconsumption_logs == nil {
		m.removedconsumption_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.consumption_logs, ids[i])
		m.removedconsumption_logs[ids[i]] = struct{}{}
	}
}

// RemovedConsumptionLogs returns the removed IDs of the "consumption_logs" edge to the ConsumptionLog entity.
func (m *ActiveIngredientMutation) RemovedConsumptionLogsIDs() (ids []int) {
	for id := range m.removedconsumption_logs {
		ids = append(ids, id)
	}
	return
}

// ConsumptionLogsIDs returns the "consumption_logs" edge IDs in the mutation.
func (m *ActiveIngredientMutation) ConsumptionLogsIDs() (ids []int) {
	for id := range m.consumption_logs {
		ids = append(ids, id)
	}
	return
}

// ResetConsumptionLogs resets all changes to the "consumption_logs" edge.
func (m *ActiveIngredientMutation) ResetConsumptionLogs() {
	m.consumption_logs = nil
	m.clearedconsumption_logs = false
	m.removedconsumption_logs = nil
}

// Where appends a list predicates to the ActiveIngredientMutation builder.
func (m *ActiveIngredientMutation) Where(ps ...predicate.ActiveIngredient) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActiveIngredientMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActiveIngredientMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ActiveIngredient, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActiveIngredientMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActiveIngredientMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ActiveIngredient).
func (m *ActiveIngredientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActiveIngredientMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, activeingredient.FieldName)
	}
	if m.stock != nil {
		fields = append(fields, activeingredient.FieldStock)
	}
	if m.unit != nil {
		fields = append(fields, activeingredient.FieldUnit)
	}
	if m.last_stocked_at != nil {
		fields = append(fields, activeingredient.FieldLastStockedAt)
	}
	if m.last_consumed_at != nil {
		fields = append(fields, activeingredient.FieldLastConsumedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActiveIngredientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activeingredient.FieldName:
		return m.Name()
	case activeingredient.FieldStock:
		return m.Stock()
	case activeingredient.FieldUnit:
		return m.Unit()
	case activeingredient.FieldLastStockedAt:
		return m.LastStockedAt()
	case activeingredient.FieldLastConsumedAt:
		return m.LastConsumedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActiveIngredientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activeingredient.FieldName:
		return m.OldName(ctx)
	case activeingredient.FieldStock:
		return m.OldStock(ctx)
	case activeingredient.FieldUnit:
		return m.OldUnit(ctx)
	case activeingredient.FieldLastStockedAt:
		return m.OldLastStockedAt(ctx)
	case activeingredient.FieldLastConsumedAt:
		return m.OldLastConsumedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ActiveIngredient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActiveIngredientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activeingredient.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case activeingredient.FieldStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStock(v)
		return nil
	case activeingredient.FieldUnit:
		v, ok := value.(activeingredient.Unit)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case activeingredient.FieldLastStockedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastStockedAt(v)
		return nil
	case activeingredient.FieldLastConsumedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastConsumedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ActiveIngredient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActiveIngredientMutation) AddedFields() []string {
	var fields []string
	if m.addstock != nil {
		fields = append(fields, activeingredient.FieldStock)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActiveIngredientMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case activeingredient.FieldStock:
		return m.AddedStock()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActiveIngredientMutation) AddField(name string, value ent.Value) error {
	switch name {
	case activeingredient.FieldStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStock(v)
		return nil
	}
	return fmt.Errorf("unknown ActiveIngredient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActiveIngredientMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activeingredient.FieldStock) {
		fields = append(fields, activeingredient.FieldStock)
	}
	if m.FieldCleared(activeingredient.FieldUnit) {
		fields = append(fields, activeingredient.FieldUnit)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActiveIngredientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActiveIngredientMutation) ClearField(name string) error {
	switch name {
	case activeingredient.FieldStock:
		m.ClearStock()
		return nil
	case activeingredient.FieldUnit:
		m.ClearUnit()
		return nil
	}
	return fmt.Errorf("unknown ActiveIngredient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActiveIngredientMutation) ResetField(name string) error {
	switch name {
	case activeingredient.FieldName:
		m.ResetName()
		return nil
	case activeingredient.FieldStock:
		m.ResetStock()
		return nil
	case activeingredient.FieldUnit:
		m.ResetUnit()
		return nil
	case activeingredient.FieldLastStockedAt:
		m.ResetLastStockedAt()
		return nil
	case activeingredient.FieldLastConsumedAt:
		m.ResetLastConsumedAt()
		return nil
	}
	return fmt.Errorf("unknown ActiveIngredient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActiveIngredientMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.medicines != nil {
		edges = append(edges, activeingredient.EdgeMedicines)
	}
	if m.prescriptions != nil {
		edges = append(edges, activeingredient.EdgePrescriptions)
	}
	if m.stocking_logs != nil {
		edges = append(edges, activeingredient.EdgeStockingLogs)
	}
	if m.consumption_logs != nil {
		edges = append(edges, activeingredient.EdgeConsumptionLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActiveIngredientMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activeingredient.EdgeMedicines:
		ids := make([]ent.Value, 0, len(m.medicines))
		for id := range m.medicines {
			ids = append(ids, id)
		}
		return ids
	case activeingredient.EdgePrescriptions:
		ids := make([]ent.Value, 0, len(m.prescriptions))
		for id := range m.prescriptions {
			ids = append(ids, id)
		}
		return ids
	case activeingredient.EdgeStockingLogs:
		ids := make([]ent.Value, 0, len(m.stocking_logs))
		for id := range m.stocking_logs {
			ids = append(ids, id)
		}
		return ids
	case activeingredient.EdgeConsumptionLogs:
		ids := make([]ent.Value, 0, len(m.consumption_logs))
		for id := range m.consumption_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActiveIngredientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmedicines != nil {
		edges = append(edges, activeingredient.EdgeMedicines)
	}
	if m.removedprescriptions != nil {
		edges = append(edges, activeingredient.EdgePrescriptions)
	}
	if m.removedstocking_logs != nil {
		edges = append(edges, activeingredient.EdgeStockingLogs)
	}
	if m.removedconsumption_logs != nil {
		edges = append(edges, activeingredient.EdgeConsumptionLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActiveIngredientMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case activeingredient.EdgeMedicines:
		ids := make([]ent.Value, 0, len(m.removedmedicines))
		for id := range m.removedmedicines {
			ids = append(ids, id)
		}
		return ids
	case activeingredient.EdgePrescriptions:
		ids := make([]ent.Value, 0, len(m.removedprescriptions))
		for id := range m.removedprescriptions {
			ids = append(ids, id)
		}
		return ids
	case activeingredient.EdgeStockingLogs:
		ids := make([]ent.Value, 0, len(m.removedstocking_logs))
		for id := range m.removedstocking_logs {
			ids = append(ids, id)
		}
		return ids
	case activeingredient.EdgeConsumptionLogs:
		ids := make([]ent.Value, 0, len(m.removedconsumption_logs))
		for id := range m.removedconsumption_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActiveIngredientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmedicines {
		edges = append(edges, activeingredient.EdgeMedicines)
	}
	if m.clearedprescriptions {
		edges = append(edges, activeingredient.EdgePrescriptions)
	}
	if m.clearedstocking_logs {
		edges = append(edges, activeingredient.EdgeStockingLogs)
	}
	if m.clearedconsumption_logs {
		edges = append(edges, activeingredient.EdgeConsumptionLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActiveIngredientMutation) EdgeCleared(name string) bool {
	switch name {
	case activeingredient.EdgeMedicines:
		return m.clearedmedicines
	case activeingredient.EdgePrescriptions:
		return m.clearedprescriptions
	case activeingredient.EdgeStockingLogs:
		return m.clearedstocking_logs
	case activeingredient.EdgeConsumptionLogs:
		return m.clearedconsumption_logs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActiveIngredientMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ActiveIngredient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActiveIngredientMutation) ResetEdge(name string) error {
	switch name {
	case activeingredient.EdgeMedicines:
		m.ResetMedicines()
		return nil
	case activeingredient.EdgePrescriptions:
		m.ResetPrescriptions()
		return nil
	case activeingredient.EdgeStockingLogs:
		m.ResetStockingLogs()
		return nil
	case activeingredient.EdgeConsumptionLogs:
		m.ResetConsumptionLogs()
		return nil
	}
	return fmt.Errorf("unknown ActiveIngredient edge %s", name)
}

// ConsumptionLogMutation represents an operation that mutates the ConsumptionLog nodes in the graph.
type ConsumptionLogMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	consumed_at         *time.Time
	units               *int
	addunits            *int
	clearedFields       map[string]struct{}
	prescription        *int
	clearedprescription bool
	done                bool
	oldValue            func(context.Context) (*ConsumptionLog, error)
	predicates          []predicate.ConsumptionLog
}

var _ ent.Mutation = (*ConsumptionLogMutation)(nil)

// consumptionlogOption allows management of the mutation configuration using functional options.
type consumptionlogOption func(*ConsumptionLogMutation)

// newConsumptionLogMutation creates new mutation for the ConsumptionLog entity.
func newConsumptionLogMutation(c config, op Op, opts ...consumptionlogOption) *ConsumptionLogMutation {
	m := &ConsumptionLogMutation{
		config:        c,
		op:            op,
		typ:           TypeConsumptionLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConsumptionLogID sets the ID field of the mutation.
func withConsumptionLogID(id int) consumptionlogOption {
	return func(m *ConsumptionLogMutation) {
		var (
			err   error
			once  sync.Once
			value *ConsumptionLog
		)
		m.oldValue = func(ctx context.Context) (*ConsumptionLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ConsumptionLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConsumptionLog sets the old ConsumptionLog of the mutation.
func withConsumptionLog(node *ConsumptionLog) consumptionlogOption {
	return func(m *ConsumptionLogMutation) {
		m.oldValue = func(context.Context) (*ConsumptionLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConsumptionLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConsumptionLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConsumptionLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConsumptionLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ConsumptionLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetConsumedAt sets the "consumed_at" field.
func (m *ConsumptionLogMutation) SetConsumedAt(t time.Time) {
	m.consumed_at = &t
}

// ConsumedAt returns the value of the "consumed_at" field in the mutation.
func (m *ConsumptionLogMutation) ConsumedAt() (r time.Time, exists bool) {
	v := m.consumed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldConsumedAt returns the old "consumed_at" field's value of the ConsumptionLog entity.
// If the ConsumptionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumptionLogMutation) OldConsumedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsumedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsumedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsumedAt: %w", err)
	}
	return oldValue.ConsumedAt, nil
}

// ClearConsumedAt clears the value of the "consumed_at" field.
func (m *ConsumptionLogMutation) ClearConsumedAt() {
	m.consumed_at = nil
	m.clearedFields[consumptionlog.FieldConsumedAt] = struct{}{}
}

// ConsumedAtCleared returns if the "consumed_at" field was cleared in this mutation.
func (m *ConsumptionLogMutation) ConsumedAtCleared() bool {
	_, ok := m.clearedFields[consumptionlog.FieldConsumedAt]
	return ok
}

// ResetConsumedAt resets all changes to the "consumed_at" field.
func (m *ConsumptionLogMutation) ResetConsumedAt() {
	m.consumed_at = nil
	delete(m.clearedFields, consumptionlog.FieldConsumedAt)
}

// SetUnits sets the "units" field.
func (m *ConsumptionLogMutation) SetUnits(i int) {
	m.units = &i
	m.addunits = nil
}

// Units returns the value of the "units" field in the mutation.
func (m *ConsumptionLogMutation) Units() (r int, exists bool) {
	v := m.units
	if v == nil {
		return
	}
	return *v, true
}

// OldUnits returns the old "units" field's value of the ConsumptionLog entity.
// If the ConsumptionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumptionLogMutation) OldUnits(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnits: %w", err)
	}
	return oldValue.Units, nil
}

// AddUnits adds i to the "units" field.
func (m *ConsumptionLogMutation) AddUnits(i int) {
	if m.addunits != nil {
		*m.addunits += i
	} else {
		m.addunits = &i
	}
}

// AddedUnits returns the value that was added to the "units" field in this mutation.
func (m *ConsumptionLogMutation) AddedUnits() (r int, exists bool) {
	v := m.addunits
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnits resets all changes to the "units" field.
func (m *ConsumptionLogMutation) ResetUnits() {
	m.units = nil
	m.addunits = nil
}

// SetPrescriptionID sets the "prescription" edge to the Prescription entity by id.
func (m *ConsumptionLogMutation) SetPrescriptionID(id int) {
	m.prescription = &id
}

// ClearPrescription clears the "prescription" edge to the Prescription entity.
func (m *ConsumptionLogMutation) ClearPrescription() {
	m.clearedprescription = true
}

// PrescriptionCleared reports if the "prescription" edge to the Prescription entity was cleared.
func (m *ConsumptionLogMutation) PrescriptionCleared() bool {
	return m.clearedprescription
}

// PrescriptionID returns the "prescription" edge ID in the mutation.
func (m *ConsumptionLogMutation) PrescriptionID() (id int, exists bool) {
	if m.prescription != nil {
		return *m.prescription, true
	}
	return
}

// PrescriptionIDs returns the "prescription" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrescriptionID instead. It exists only for internal usage by the builders.
func (m *ConsumptionLogMutation) PrescriptionIDs() (ids []int) {
	if id := m.prescription; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrescription resets all changes to the "prescription" edge.
func (m *ConsumptionLogMutation) ResetPrescription() {
	m.prescription = nil
	m.clearedprescription = false
}

// Where appends a list predicates to the ConsumptionLogMutation builder.
func (m *ConsumptionLogMutation) Where(ps ...predicate.ConsumptionLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConsumptionLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConsumptionLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ConsumptionLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConsumptionLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConsumptionLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ConsumptionLog).
func (m *ConsumptionLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConsumptionLogMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.consumed_at != nil {
		fields = append(fields, consumptionlog.FieldConsumedAt)
	}
	if m.units != nil {
		fields = append(fields, consumptionlog.FieldUnits)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConsumptionLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case consumptionlog.FieldConsumedAt:
		return m.ConsumedAt()
	case consumptionlog.FieldUnits:
		return m.Units()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConsumptionLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case consumptionlog.FieldConsumedAt:
		return m.OldConsumedAt(ctx)
	case consumptionlog.FieldUnits:
		return m.OldUnits(ctx)
	}
	return nil, fmt.Errorf("unknown ConsumptionLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConsumptionLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case consumptionlog.FieldConsumedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsumedAt(v)
		return nil
	case consumptionlog.FieldUnits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnits(v)
		return nil
	}
	return fmt.Errorf("unknown ConsumptionLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConsumptionLogMutation) AddedFields() []string {
	var fields []string
	if m.addunits != nil {
		fields = append(fields, consumptionlog.FieldUnits)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConsumptionLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case consumptionlog.FieldUnits:
		return m.AddedUnits()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConsumptionLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case consumptionlog.FieldUnits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnits(v)
		return nil
	}
	return fmt.Errorf("unknown ConsumptionLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConsumptionLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(consumptionlog.FieldConsumedAt) {
		fields = append(fields, consumptionlog.FieldConsumedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConsumptionLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConsumptionLogMutation) ClearField(name string) error {
	switch name {
	case consumptionlog.FieldConsumedAt:
		m.ClearConsumedAt()
		return nil
	}
	return fmt.Errorf("unknown ConsumptionLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConsumptionLogMutation) ResetField(name string) error {
	switch name {
	case consumptionlog.FieldConsumedAt:
		m.ResetConsumedAt()
		return nil
	case consumptionlog.FieldUnits:
		m.ResetUnits()
		return nil
	}
	return fmt.Errorf("unknown ConsumptionLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConsumptionLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.prescription != nil {
		edges = append(edges, consumptionlog.EdgePrescription)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConsumptionLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case consumptionlog.EdgePrescription:
		if id := m.prescription; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConsumptionLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConsumptionLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConsumptionLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprescription {
		edges = append(edges, consumptionlog.EdgePrescription)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConsumptionLogMutation) EdgeCleared(name string) bool {
	switch name {
	case consumptionlog.EdgePrescription:
		return m.clearedprescription
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConsumptionLogMutation) ClearEdge(name string) error {
	switch name {
	case consumptionlog.EdgePrescription:
		m.ClearPrescription()
		return nil
	}
	return fmt.Errorf("unknown ConsumptionLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConsumptionLogMutation) ResetEdge(name string) error {
	switch name {
	case consumptionlog.EdgePrescription:
		m.ResetPrescription()
		return nil
	}
	return fmt.Errorf("unknown ConsumptionLog edge %s", name)
}

// MedicineMutation represents an operation that mutates the Medicine nodes in the graph.
type MedicineMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	name                     *string
	mah                      *string
	dosage                   *float64
	adddosage                *float64
	atc                      *string
	_package                 *string
	form                     *string
	box_size                 *int
	addbox_size              *int
	clearedFields            map[string]struct{}
	stocking_logs            map[int]struct{}
	removedstocking_logs     map[int]struct{}
	clearedstocking_logs     bool
	active_ingredient        *int
	clearedactive_ingredient bool
	done                     bool
	oldValue                 func(context.Context) (*Medicine, error)
	predicates               []predicate.Medicine
}

var _ ent.Mutation = (*MedicineMutation)(nil)

// medicineOption allows management of the mutation configuration using functional options.
type medicineOption func(*MedicineMutation)

// newMedicineMutation creates new mutation for the Medicine entity.
func newMedicineMutation(c config, op Op, opts ...medicineOption) *MedicineMutation {
	m := &MedicineMutation{
		config:        c,
		op:            op,
		typ:           TypeMedicine,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMedicineID sets the ID field of the mutation.
func withMedicineID(id int) medicineOption {
	return func(m *MedicineMutation) {
		var (
			err   error
			once  sync.Once
			value *Medicine
		)
		m.oldValue = func(ctx context.Context) (*Medicine, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Medicine.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedicine sets the old Medicine of the mutation.
func withMedicine(node *Medicine) medicineOption {
	return func(m *MedicineMutation) {
		m.oldValue = func(context.Context) (*Medicine, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MedicineMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MedicineMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MedicineMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MedicineMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Medicine.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MedicineMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MedicineMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Medicine entity.
// If the Medicine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicineMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MedicineMutation) ResetName() {
	m.name = nil
}

// SetMah sets the "mah" field.
func (m *MedicineMutation) SetMah(s string) {
	m.mah = &s
}

// Mah returns the value of the "mah" field in the mutation.
func (m *MedicineMutation) Mah() (r string, exists bool) {
	v := m.mah
	if v == nil {
		return
	}
	return *v, true
}

// OldMah returns the old "mah" field's value of the Medicine entity.
// If the Medicine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicineMutation) OldMah(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMah is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMah requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMah: %w", err)
	}
	return oldValue.Mah, nil
}

// ResetMah resets all changes to the "mah" field.
func (m *MedicineMutation) ResetMah() {
	m.mah = nil
}

// SetDosage sets the "dosage" field.
func (m *MedicineMutation) SetDosage(f float64) {
	m.dosage = &f
	m.adddosage = nil
}

// Dosage returns the value of the "dosage" field in the mutation.
func (m *MedicineMutation) Dosage() (r float64, exists bool) {
	v := m.dosage
	if v == nil {
		return
	}
	return *v, true
}

// OldDosage returns the old "dosage" field's value of the Medicine entity.
// If the Medicine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicineMutation) OldDosage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDosage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDosage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDosage: %w", err)
	}
	return oldValue.Dosage, nil
}

// AddDosage adds f to the "dosage" field.
func (m *MedicineMutation) AddDosage(f float64) {
	if m.adddosage != nil {
		*m.adddosage += f
	} else {
		m.adddosage = &f
	}
}

// AddedDosage returns the value that was added to the "dosage" field in this mutation.
func (m *MedicineMutation) AddedDosage() (r float64, exists bool) {
	v := m.adddosage
	if v == nil {
		return
	}
	return *v, true
}

// ResetDosage resets all changes to the "dosage" field.
func (m *MedicineMutation) ResetDosage() {
	m.dosage = nil
	m.adddosage = nil
}

// SetAtc sets the "atc" field.
func (m *MedicineMutation) SetAtc(s string) {
	m.atc = &s
}

// Atc returns the value of the "atc" field in the mutation.
func (m *MedicineMutation) Atc() (r string, exists bool) {
	v := m.atc
	if v == nil {
		return
	}
	return *v, true
}

// OldAtc returns the old "atc" field's value of the Medicine entity.
// If the Medicine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicineMutation) OldAtc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAtc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAtc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAtc: %w", err)
	}
	return oldValue.Atc, nil
}

// ResetAtc resets all changes to the "atc" field.
func (m *MedicineMutation) ResetAtc() {
	m.atc = nil
}

// SetPackage sets the "package" field.
func (m *MedicineMutation) SetPackage(s string) {
	m._package = &s
}

// Package returns the value of the "package" field in the mutation.
func (m *MedicineMutation) Package() (r string, exists bool) {
	v := m._package
	if v == nil {
		return
	}
	return *v, true
}

// OldPackage returns the old "package" field's value of the Medicine entity.
// If the Medicine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicineMutation) OldPackage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackage: %w", err)
	}
	return oldValue.Package, nil
}

// ResetPackage resets all changes to the "package" field.
func (m *MedicineMutation) ResetPackage() {
	m._package = nil
}

// SetForm sets the "form" field.
func (m *MedicineMutation) SetForm(s string) {
	m.form = &s
}

// Form returns the value of the "form" field in the mutation.
func (m *MedicineMutation) Form() (r string, exists bool) {
	v := m.form
	if v == nil {
		return
	}
	return *v, true
}

// OldForm returns the old "form" field's value of the Medicine entity.
// If the Medicine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicineMutation) OldForm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForm: %w", err)
	}
	return oldValue.Form, nil
}

// ResetForm resets all changes to the "form" field.
func (m *MedicineMutation) ResetForm() {
	m.form = nil
}

// SetBoxSize sets the "box_size" field.
func (m *MedicineMutation) SetBoxSize(i int) {
	m.box_size = &i
	m.addbox_size = nil
}

// BoxSize returns the value of the "box_size" field in the mutation.
func (m *MedicineMutation) BoxSize() (r int, exists bool) {
	v := m.box_size
	if v == nil {
		return
	}
	return *v, true
}

// OldBoxSize returns the old "box_size" field's value of the Medicine entity.
// If the Medicine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MedicineMutation) OldBoxSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBoxSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBoxSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBoxSize: %w", err)
	}
	return oldValue.BoxSize, nil
}

// AddBoxSize adds i to the "box_size" field.
func (m *MedicineMutation) AddBoxSize(i int) {
	if m.addbox_size != nil {
		*m.addbox_size += i
	} else {
		m.addbox_size = &i
	}
}

// AddedBoxSize returns the value that was added to the "box_size" field in this mutation.
func (m *MedicineMutation) AddedBoxSize() (r int, exists bool) {
	v := m.addbox_size
	if v == nil {
		return
	}
	return *v, true
}

// ResetBoxSize resets all changes to the "box_size" field.
func (m *MedicineMutation) ResetBoxSize() {
	m.box_size = nil
	m.addbox_size = nil
}

// AddStockingLogIDs adds the "stocking_logs" edge to the StockingLog entity by ids.
func (m *MedicineMutation) AddStockingLogIDs(ids ...int) {
	if m.stocking_logs == nil {
		m.stocking_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.stocking_logs[ids[i]] = struct{}{}
	}
}

// ClearStockingLogs clears the "stocking_logs" edge to the StockingLog entity.
func (m *MedicineMutation) ClearStockingLogs() {
	m.clearedstocking_logs = true
}

// StockingLogsCleared reports if the "stocking_logs" edge to the StockingLog entity was cleared.
func (m *MedicineMutation) StockingLogsCleared() bool {
	return m.clearedstocking_logs
}

// RemoveStockingLogIDs removes the "stocking_logs" edge to the StockingLog entity by IDs.
func (m *MedicineMutation) RemoveStockingLogIDs(ids ...int) {
	if m.removedstocking_logs == nil {
		m.removedstocking_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.stocking_logs, ids[i])
		m.removedstocking_logs[ids[i]] = struct{}{}
	}
}

// RemovedStockingLogs returns the removed IDs of the "stocking_logs" edge to the StockingLog entity.
func (m *MedicineMutation) RemovedStockingLogsIDs() (ids []int) {
	for id := range m.removedstocking_logs {
		ids = append(ids, id)
	}
	return
}

// StockingLogsIDs returns the "stocking_logs" edge IDs in the mutation.
func (m *MedicineMutation) StockingLogsIDs() (ids []int) {
	for id := range m.stocking_logs {
		ids = append(ids, id)
	}
	return
}

// ResetStockingLogs resets all changes to the "stocking_logs" edge.
func (m *MedicineMutation) ResetStockingLogs() {
	m.stocking_logs = nil
	m.clearedstocking_logs = false
	m.removedstocking_logs = nil
}

// SetActiveIngredientID sets the "active_ingredient" edge to the ActiveIngredient entity by id.
func (m *MedicineMutation) SetActiveIngredientID(id int) {
	m.active_ingredient = &id
}

// ClearActiveIngredient clears the "active_ingredient" edge to the ActiveIngredient entity.
func (m *MedicineMutation) ClearActiveIngredient() {
	m.clearedactive_ingredient = true
}

// ActiveIngredientCleared reports if the "active_ingredient" edge to the ActiveIngredient entity was cleared.
func (m *MedicineMutation) ActiveIngredientCleared() bool {
	return m.clearedactive_ingredient
}

// ActiveIngredientID returns the "active_ingredient" edge ID in the mutation.
func (m *MedicineMutation) ActiveIngredientID() (id int, exists bool) {
	if m.active_ingredient != nil {
		return *m.active_ingredient, true
	}
	return
}

// ActiveIngredientIDs returns the "active_ingredient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActiveIngredientID instead. It exists only for internal usage by the builders.
func (m *MedicineMutation) ActiveIngredientIDs() (ids []int) {
	if id := m.active_ingredient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActiveIngredient resets all changes to the "active_ingredient" edge.
func (m *MedicineMutation) ResetActiveIngredient() {
	m.active_ingredient = nil
	m.clearedactive_ingredient = false
}

// Where appends a list predicates to the MedicineMutation builder.
func (m *MedicineMutation) Where(ps ...predicate.Medicine) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MedicineMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MedicineMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Medicine, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MedicineMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MedicineMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Medicine).
func (m *MedicineMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MedicineMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, medicine.FieldName)
	}
	if m.mah != nil {
		fields = append(fields, medicine.FieldMah)
	}
	if m.dosage != nil {
		fields = append(fields, medicine.FieldDosage)
	}
	if m.atc != nil {
		fields = append(fields, medicine.FieldAtc)
	}
	if m._package != nil {
		fields = append(fields, medicine.FieldPackage)
	}
	if m.form != nil {
		fields = append(fields, medicine.FieldForm)
	}
	if m.box_size != nil {
		fields = append(fields, medicine.FieldBoxSize)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MedicineMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case medicine.FieldName:
		return m.Name()
	case medicine.FieldMah:
		return m.Mah()
	case medicine.FieldDosage:
		return m.Dosage()
	case medicine.FieldAtc:
		return m.Atc()
	case medicine.FieldPackage:
		return m.Package()
	case medicine.FieldForm:
		return m.Form()
	case medicine.FieldBoxSize:
		return m.BoxSize()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MedicineMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case medicine.FieldName:
		return m.OldName(ctx)
	case medicine.FieldMah:
		return m.OldMah(ctx)
	case medicine.FieldDosage:
		return m.OldDosage(ctx)
	case medicine.FieldAtc:
		return m.OldAtc(ctx)
	case medicine.FieldPackage:
		return m.OldPackage(ctx)
	case medicine.FieldForm:
		return m.OldForm(ctx)
	case medicine.FieldBoxSize:
		return m.OldBoxSize(ctx)
	}
	return nil, fmt.Errorf("unknown Medicine field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MedicineMutation) SetField(name string, value ent.Value) error {
	switch name {
	case medicine.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case medicine.FieldMah:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMah(v)
		return nil
	case medicine.FieldDosage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDosage(v)
		return nil
	case medicine.FieldAtc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAtc(v)
		return nil
	case medicine.FieldPackage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackage(v)
		return nil
	case medicine.FieldForm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForm(v)
		return nil
	case medicine.FieldBoxSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBoxSize(v)
		return nil
	}
	return fmt.Errorf("unknown Medicine field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MedicineMutation) AddedFields() []string {
	var fields []string
	if m.adddosage != nil {
		fields = append(fields, medicine.FieldDosage)
	}
	if m.addbox_size != nil {
		fields = append(fields, medicine.FieldBoxSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MedicineMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case medicine.FieldDosage:
		return m.AddedDosage()
	case medicine.FieldBoxSize:
		return m.AddedBoxSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MedicineMutation) AddField(name string, value ent.Value) error {
	switch name {
	case medicine.FieldDosage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDosage(v)
		return nil
	case medicine.FieldBoxSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBoxSize(v)
		return nil
	}
	return fmt.Errorf("unknown Medicine numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MedicineMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MedicineMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MedicineMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Medicine nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MedicineMutation) ResetField(name string) error {
	switch name {
	case medicine.FieldName:
		m.ResetName()
		return nil
	case medicine.FieldMah:
		m.ResetMah()
		return nil
	case medicine.FieldDosage:
		m.ResetDosage()
		return nil
	case medicine.FieldAtc:
		m.ResetAtc()
		return nil
	case medicine.FieldPackage:
		m.ResetPackage()
		return nil
	case medicine.FieldForm:
		m.ResetForm()
		return nil
	case medicine.FieldBoxSize:
		m.ResetBoxSize()
		return nil
	}
	return fmt.Errorf("unknown Medicine field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MedicineMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.stocking_logs != nil {
		edges = append(edges, medicine.EdgeStockingLogs)
	}
	if m.active_ingredient != nil {
		edges = append(edges, medicine.EdgeActiveIngredient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MedicineMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case medicine.EdgeStockingLogs:
		ids := make([]ent.Value, 0, len(m.stocking_logs))
		for id := range m.stocking_logs {
			ids = append(ids, id)
		}
		return ids
	case medicine.EdgeActiveIngredient:
		if id := m.active_ingredient; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MedicineMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedstocking_logs != nil {
		edges = append(edges, medicine.EdgeStockingLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MedicineMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case medicine.EdgeStockingLogs:
		ids := make([]ent.Value, 0, len(m.removedstocking_logs))
		for id := range m.removedstocking_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MedicineMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstocking_logs {
		edges = append(edges, medicine.EdgeStockingLogs)
	}
	if m.clearedactive_ingredient {
		edges = append(edges, medicine.EdgeActiveIngredient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MedicineMutation) EdgeCleared(name string) bool {
	switch name {
	case medicine.EdgeStockingLogs:
		return m.clearedstocking_logs
	case medicine.EdgeActiveIngredient:
		return m.clearedactive_ingredient
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MedicineMutation) ClearEdge(name string) error {
	switch name {
	case medicine.EdgeActiveIngredient:
		m.ClearActiveIngredient()
		return nil
	}
	return fmt.Errorf("unknown Medicine unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MedicineMutation) ResetEdge(name string) error {
	switch name {
	case medicine.EdgeStockingLogs:
		m.ResetStockingLogs()
		return nil
	case medicine.EdgeActiveIngredient:
		m.ResetActiveIngredient()
		return nil
	}
	return fmt.Errorf("unknown Medicine edge %s", name)
}

// PrescriptionMutation represents an operation that mutates the Prescription nodes in the graph.
type PrescriptionMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	dosage                   *int
	adddosage                *int
	dosage_frequency         *int
	adddosage_frequency      *int
	start_date               *time.Time
	end_date                 *time.Time
	clearedFields            map[string]struct{}
	comsumption_logs         map[int]struct{}
	removedcomsumption_logs  map[int]struct{}
	clearedcomsumption_logs  bool
	active_ingredient        *int
	clearedactive_ingredient bool
	done                     bool
	oldValue                 func(context.Context) (*Prescription, error)
	predicates               []predicate.Prescription
}

var _ ent.Mutation = (*PrescriptionMutation)(nil)

// prescriptionOption allows management of the mutation configuration using functional options.
type prescriptionOption func(*PrescriptionMutation)

// newPrescriptionMutation creates new mutation for the Prescription entity.
func newPrescriptionMutation(c config, op Op, opts ...prescriptionOption) *PrescriptionMutation {
	m := &PrescriptionMutation{
		config:        c,
		op:            op,
		typ:           TypePrescription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPrescriptionID sets the ID field of the mutation.
func withPrescriptionID(id int) prescriptionOption {
	return func(m *PrescriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *Prescription
		)
		m.oldValue = func(ctx context.Context) (*Prescription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Prescription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrescription sets the old Prescription of the mutation.
func withPrescription(node *Prescription) prescriptionOption {
	return func(m *PrescriptionMutation) {
		m.oldValue = func(context.Context) (*Prescription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PrescriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PrescriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PrescriptionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PrescriptionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Prescription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDosage sets the "dosage" field.
func (m *PrescriptionMutation) SetDosage(i int) {
	m.dosage = &i
	m.adddosage = nil
}

// Dosage returns the value of the "dosage" field in the mutation.
func (m *PrescriptionMutation) Dosage() (r int, exists bool) {
	v := m.dosage
	if v == nil {
		return
	}
	return *v, true
}

// OldDosage returns the old "dosage" field's value of the Prescription entity.
// If the Prescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrescriptionMutation) OldDosage(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDosage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDosage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDosage: %w", err)
	}
	return oldValue.Dosage, nil
}

// AddDosage adds i to the "dosage" field.
func (m *PrescriptionMutation) AddDosage(i int) {
	if m.adddosage != nil {
		*m.adddosage += i
	} else {
		m.adddosage = &i
	}
}

// AddedDosage returns the value that was added to the "dosage" field in this mutation.
func (m *PrescriptionMutation) AddedDosage() (r int, exists bool) {
	v := m.adddosage
	if v == nil {
		return
	}
	return *v, true
}

// ResetDosage resets all changes to the "dosage" field.
func (m *PrescriptionMutation) ResetDosage() {
	m.dosage = nil
	m.adddosage = nil
}

// SetDosageFrequency sets the "dosage_frequency" field.
func (m *PrescriptionMutation) SetDosageFrequency(i int) {
	m.dosage_frequency = &i
	m.adddosage_frequency = nil
}

// DosageFrequency returns the value of the "dosage_frequency" field in the mutation.
func (m *PrescriptionMutation) DosageFrequency() (r int, exists bool) {
	v := m.dosage_frequency
	if v == nil {
		return
	}
	return *v, true
}

// OldDosageFrequency returns the old "dosage_frequency" field's value of the Prescription entity.
// If the Prescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrescriptionMutation) OldDosageFrequency(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDosageFrequency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDosageFrequency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDosageFrequency: %w", err)
	}
	return oldValue.DosageFrequency, nil
}

// AddDosageFrequency adds i to the "dosage_frequency" field.
func (m *PrescriptionMutation) AddDosageFrequency(i int) {
	if m.adddosage_frequency != nil {
		*m.adddosage_frequency += i
	} else {
		m.adddosage_frequency = &i
	}
}

// AddedDosageFrequency returns the value that was added to the "dosage_frequency" field in this mutation.
func (m *PrescriptionMutation) AddedDosageFrequency() (r int, exists bool) {
	v := m.adddosage_frequency
	if v == nil {
		return
	}
	return *v, true
}

// ClearDosageFrequency clears the value of the "dosage_frequency" field.
func (m *PrescriptionMutation) ClearDosageFrequency() {
	m.dosage_frequency = nil
	m.adddosage_frequency = nil
	m.clearedFields[prescription.FieldDosageFrequency] = struct{}{}
}

// DosageFrequencyCleared returns if the "dosage_frequency" field was cleared in this mutation.
func (m *PrescriptionMutation) DosageFrequencyCleared() bool {
	_, ok := m.clearedFields[prescription.FieldDosageFrequency]
	return ok
}

// ResetDosageFrequency resets all changes to the "dosage_frequency" field.
func (m *PrescriptionMutation) ResetDosageFrequency() {
	m.dosage_frequency = nil
	m.adddosage_frequency = nil
	delete(m.clearedFields, prescription.FieldDosageFrequency)
}

// SetStartDate sets the "start_date" field.
func (m *PrescriptionMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *PrescriptionMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Prescription entity.
// If the Prescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrescriptionMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *PrescriptionMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[prescription.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *PrescriptionMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[prescription.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *PrescriptionMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, prescription.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *PrescriptionMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *PrescriptionMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Prescription entity.
// If the Prescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrescriptionMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *PrescriptionMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[prescription.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *PrescriptionMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[prescription.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *PrescriptionMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, prescription.FieldEndDate)
}

// AddComsumptionLogIDs adds the "comsumption_logs" edge to the ConsumptionLog entity by ids.
func (m *PrescriptionMutation) AddComsumptionLogIDs(ids ...int) {
	if m.comsumption_logs == nil {
		m.comsumption_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.comsumption_logs[ids[i]] = struct{}{}
	}
}

// ClearComsumptionLogs clears the "comsumption_logs" edge to the ConsumptionLog entity.
func (m *PrescriptionMutation) ClearComsumptionLogs() {
	m.clearedcomsumption_logs = true
}

// ComsumptionLogsCleared reports if the "comsumption_logs" edge to the ConsumptionLog entity was cleared.
func (m *PrescriptionMutation) ComsumptionLogsCleared() bool {
	return m.clearedcomsumption_logs
}

// RemoveComsumptionLogIDs removes the "comsumption_logs" edge to the ConsumptionLog entity by IDs.
func (m *PrescriptionMutation) RemoveComsumptionLogIDs(ids ...int) {
	if m.removedcomsumption_logs == nil {
		m.removedcomsumption_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.comsumption_logs, ids[i])
		m.removedcomsumption_logs[ids[i]] = struct{}{}
	}
}

// RemovedComsumptionLogs returns the removed IDs of the "comsumption_logs" edge to the ConsumptionLog entity.
func (m *PrescriptionMutation) RemovedComsumptionLogsIDs() (ids []int) {
	for id := range m.removedcomsumption_logs {
		ids = append(ids, id)
	}
	return
}

// ComsumptionLogsIDs returns the "comsumption_logs" edge IDs in the mutation.
func (m *PrescriptionMutation) ComsumptionLogsIDs() (ids []int) {
	for id := range m.comsumption_logs {
		ids = append(ids, id)
	}
	return
}

// ResetComsumptionLogs resets all changes to the "comsumption_logs" edge.
func (m *PrescriptionMutation) ResetComsumptionLogs() {
	m.comsumption_logs = nil
	m.clearedcomsumption_logs = false
	m.removedcomsumption_logs = nil
}

// SetActiveIngredientID sets the "active_ingredient" edge to the ActiveIngredient entity by id.
func (m *PrescriptionMutation) SetActiveIngredientID(id int) {
	m.active_ingredient = &id
}

// ClearActiveIngredient clears the "active_ingredient" edge to the ActiveIngredient entity.
func (m *PrescriptionMutation) ClearActiveIngredient() {
	m.clearedactive_ingredient = true
}

// ActiveIngredientCleared reports if the "active_ingredient" edge to the ActiveIngredient entity was cleared.
func (m *PrescriptionMutation) ActiveIngredientCleared() bool {
	return m.clearedactive_ingredient
}

// ActiveIngredientID returns the "active_ingredient" edge ID in the mutation.
func (m *PrescriptionMutation) ActiveIngredientID() (id int, exists bool) {
	if m.active_ingredient != nil {
		return *m.active_ingredient, true
	}
	return
}

// ActiveIngredientIDs returns the "active_ingredient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActiveIngredientID instead. It exists only for internal usage by the builders.
func (m *PrescriptionMutation) ActiveIngredientIDs() (ids []int) {
	if id := m.active_ingredient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActiveIngredient resets all changes to the "active_ingredient" edge.
func (m *PrescriptionMutation) ResetActiveIngredient() {
	m.active_ingredient = nil
	m.clearedactive_ingredient = false
}

// Where appends a list predicates to the PrescriptionMutation builder.
func (m *PrescriptionMutation) Where(ps ...predicate.Prescription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PrescriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PrescriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Prescription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PrescriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PrescriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Prescription).
func (m *PrescriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PrescriptionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.dosage != nil {
		fields = append(fields, prescription.FieldDosage)
	}
	if m.dosage_frequency != nil {
		fields = append(fields, prescription.FieldDosageFrequency)
	}
	if m.start_date != nil {
		fields = append(fields, prescription.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, prescription.FieldEndDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PrescriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prescription.FieldDosage:
		return m.Dosage()
	case prescription.FieldDosageFrequency:
		return m.DosageFrequency()
	case prescription.FieldStartDate:
		return m.StartDate()
	case prescription.FieldEndDate:
		return m.EndDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PrescriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prescription.FieldDosage:
		return m.OldDosage(ctx)
	case prescription.FieldDosageFrequency:
		return m.OldDosageFrequency(ctx)
	case prescription.FieldStartDate:
		return m.OldStartDate(ctx)
	case prescription.FieldEndDate:
		return m.OldEndDate(ctx)
	}
	return nil, fmt.Errorf("unknown Prescription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrescriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prescription.FieldDosage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDosage(v)
		return nil
	case prescription.FieldDosageFrequency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDosageFrequency(v)
		return nil
	case prescription.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case prescription.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	}
	return fmt.Errorf("unknown Prescription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PrescriptionMutation) AddedFields() []string {
	var fields []string
	if m.adddosage != nil {
		fields = append(fields, prescription.FieldDosage)
	}
	if m.adddosage_frequency != nil {
		fields = append(fields, prescription.FieldDosageFrequency)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PrescriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case prescription.FieldDosage:
		return m.AddedDosage()
	case prescription.FieldDosageFrequency:
		return m.AddedDosageFrequency()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrescriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case prescription.FieldDosage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDosage(v)
		return nil
	case prescription.FieldDosageFrequency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDosageFrequency(v)
		return nil
	}
	return fmt.Errorf("unknown Prescription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PrescriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(prescription.FieldDosageFrequency) {
		fields = append(fields, prescription.FieldDosageFrequency)
	}
	if m.FieldCleared(prescription.FieldStartDate) {
		fields = append(fields, prescription.FieldStartDate)
	}
	if m.FieldCleared(prescription.FieldEndDate) {
		fields = append(fields, prescription.FieldEndDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PrescriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PrescriptionMutation) ClearField(name string) error {
	switch name {
	case prescription.FieldDosageFrequency:
		m.ClearDosageFrequency()
		return nil
	case prescription.FieldStartDate:
		m.ClearStartDate()
		return nil
	case prescription.FieldEndDate:
		m.ClearEndDate()
		return nil
	}
	return fmt.Errorf("unknown Prescription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PrescriptionMutation) ResetField(name string) error {
	switch name {
	case prescription.FieldDosage:
		m.ResetDosage()
		return nil
	case prescription.FieldDosageFrequency:
		m.ResetDosageFrequency()
		return nil
	case prescription.FieldStartDate:
		m.ResetStartDate()
		return nil
	case prescription.FieldEndDate:
		m.ResetEndDate()
		return nil
	}
	return fmt.Errorf("unknown Prescription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PrescriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.comsumption_logs != nil {
		edges = append(edges, prescription.EdgeComsumptionLogs)
	}
	if m.active_ingredient != nil {
		edges = append(edges, prescription.EdgeActiveIngredient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PrescriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prescription.EdgeComsumptionLogs:
		ids := make([]ent.Value, 0, len(m.comsumption_logs))
		for id := range m.comsumption_logs {
			ids = append(ids, id)
		}
		return ids
	case prescription.EdgeActiveIngredient:
		if id := m.active_ingredient; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PrescriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcomsumption_logs != nil {
		edges = append(edges, prescription.EdgeComsumptionLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PrescriptionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case prescription.EdgeComsumptionLogs:
		ids := make([]ent.Value, 0, len(m.removedcomsumption_logs))
		for id := range m.removedcomsumption_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PrescriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcomsumption_logs {
		edges = append(edges, prescription.EdgeComsumptionLogs)
	}
	if m.clearedactive_ingredient {
		edges = append(edges, prescription.EdgeActiveIngredient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PrescriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case prescription.EdgeComsumptionLogs:
		return m.clearedcomsumption_logs
	case prescription.EdgeActiveIngredient:
		return m.clearedactive_ingredient
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PrescriptionMutation) ClearEdge(name string) error {
	switch name {
	case prescription.EdgeActiveIngredient:
		m.ClearActiveIngredient()
		return nil
	}
	return fmt.Errorf("unknown Prescription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PrescriptionMutation) ResetEdge(name string) error {
	switch name {
	case prescription.EdgeComsumptionLogs:
		m.ResetComsumptionLogs()
		return nil
	case prescription.EdgeActiveIngredient:
		m.ResetActiveIngredient()
		return nil
	}
	return fmt.Errorf("unknown Prescription edge %s", name)
}

// StockingLogMutation represents an operation that mutates the StockingLog nodes in the graph.
type StockingLogMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	stocked_at               *time.Time
	boxes                    *int
	addboxes                 *int
	units                    *int
	addunits                 *int
	clearedFields            map[string]struct{}
	medicine                 *int
	clearedmedicine          bool
	active_ingredient        *int
	clearedactive_ingredient bool
	done                     bool
	oldValue                 func(context.Context) (*StockingLog, error)
	predicates               []predicate.StockingLog
}

var _ ent.Mutation = (*StockingLogMutation)(nil)

// stockinglogOption allows management of the mutation configuration using functional options.
type stockinglogOption func(*StockingLogMutation)

// newStockingLogMutation creates new mutation for the StockingLog entity.
func newStockingLogMutation(c config, op Op, opts ...stockinglogOption) *StockingLogMutation {
	m := &StockingLogMutation{
		config:        c,
		op:            op,
		typ:           TypeStockingLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStockingLogID sets the ID field of the mutation.
func withStockingLogID(id int) stockinglogOption {
	return func(m *StockingLogMutation) {
		var (
			err   error
			once  sync.Once
			value *StockingLog
		)
		m.oldValue = func(ctx context.Context) (*StockingLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StockingLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStockingLog sets the old StockingLog of the mutation.
func withStockingLog(node *StockingLog) stockinglogOption {
	return func(m *StockingLogMutation) {
		m.oldValue = func(context.Context) (*StockingLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StockingLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StockingLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StockingLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StockingLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StockingLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStockedAt sets the "stocked_at" field.
func (m *StockingLogMutation) SetStockedAt(t time.Time) {
	m.stocked_at = &t
}

// StockedAt returns the value of the "stocked_at" field in the mutation.
func (m *StockingLogMutation) StockedAt() (r time.Time, exists bool) {
	v := m.stocked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStockedAt returns the old "stocked_at" field's value of the StockingLog entity.
// If the StockingLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockingLogMutation) OldStockedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStockedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStockedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStockedAt: %w", err)
	}
	return oldValue.StockedAt, nil
}

// ClearStockedAt clears the value of the "stocked_at" field.
func (m *StockingLogMutation) ClearStockedAt() {
	m.stocked_at = nil
	m.clearedFields[stockinglog.FieldStockedAt] = struct{}{}
}

// StockedAtCleared returns if the "stocked_at" field was cleared in this mutation.
func (m *StockingLogMutation) StockedAtCleared() bool {
	_, ok := m.clearedFields[stockinglog.FieldStockedAt]
	return ok
}

// ResetStockedAt resets all changes to the "stocked_at" field.
func (m *StockingLogMutation) ResetStockedAt() {
	m.stocked_at = nil
	delete(m.clearedFields, stockinglog.FieldStockedAt)
}

// SetBoxes sets the "boxes" field.
func (m *StockingLogMutation) SetBoxes(i int) {
	m.boxes = &i
	m.addboxes = nil
}

// Boxes returns the value of the "boxes" field in the mutation.
func (m *StockingLogMutation) Boxes() (r int, exists bool) {
	v := m.boxes
	if v == nil {
		return
	}
	return *v, true
}

// OldBoxes returns the old "boxes" field's value of the StockingLog entity.
// If the StockingLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockingLogMutation) OldBoxes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBoxes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBoxes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBoxes: %w", err)
	}
	return oldValue.Boxes, nil
}

// AddBoxes adds i to the "boxes" field.
func (m *StockingLogMutation) AddBoxes(i int) {
	if m.addboxes != nil {
		*m.addboxes += i
	} else {
		m.addboxes = &i
	}
}

// AddedBoxes returns the value that was added to the "boxes" field in this mutation.
func (m *StockingLogMutation) AddedBoxes() (r int, exists bool) {
	v := m.addboxes
	if v == nil {
		return
	}
	return *v, true
}

// ClearBoxes clears the value of the "boxes" field.
func (m *StockingLogMutation) ClearBoxes() {
	m.boxes = nil
	m.addboxes = nil
	m.clearedFields[stockinglog.FieldBoxes] = struct{}{}
}

// BoxesCleared returns if the "boxes" field was cleared in this mutation.
func (m *StockingLogMutation) BoxesCleared() bool {
	_, ok := m.clearedFields[stockinglog.FieldBoxes]
	return ok
}

// ResetBoxes resets all changes to the "boxes" field.
func (m *StockingLogMutation) ResetBoxes() {
	m.boxes = nil
	m.addboxes = nil
	delete(m.clearedFields, stockinglog.FieldBoxes)
}

// SetUnits sets the "units" field.
func (m *StockingLogMutation) SetUnits(i int) {
	m.units = &i
	m.addunits = nil
}

// Units returns the value of the "units" field in the mutation.
func (m *StockingLogMutation) Units() (r int, exists bool) {
	v := m.units
	if v == nil {
		return
	}
	return *v, true
}

// OldUnits returns the old "units" field's value of the StockingLog entity.
// If the StockingLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockingLogMutation) OldUnits(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnits: %w", err)
	}
	return oldValue.Units, nil
}

// AddUnits adds i to the "units" field.
func (m *StockingLogMutation) AddUnits(i int) {
	if m.addunits != nil {
		*m.addunits += i
	} else {
		m.addunits = &i
	}
}

// AddedUnits returns the value that was added to the "units" field in this mutation.
func (m *StockingLogMutation) AddedUnits() (r int, exists bool) {
	v := m.addunits
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnits resets all changes to the "units" field.
func (m *StockingLogMutation) ResetUnits() {
	m.units = nil
	m.addunits = nil
}

// SetMedicineID sets the "medicine" edge to the Medicine entity by id.
func (m *StockingLogMutation) SetMedicineID(id int) {
	m.medicine = &id
}

// ClearMedicine clears the "medicine" edge to the Medicine entity.
func (m *StockingLogMutation) ClearMedicine() {
	m.clearedmedicine = true
}

// MedicineCleared reports if the "medicine" edge to the Medicine entity was cleared.
func (m *StockingLogMutation) MedicineCleared() bool {
	return m.clearedmedicine
}

// MedicineID returns the "medicine" edge ID in the mutation.
func (m *StockingLogMutation) MedicineID() (id int, exists bool) {
	if m.medicine != nil {
		return *m.medicine, true
	}
	return
}

// MedicineIDs returns the "medicine" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MedicineID instead. It exists only for internal usage by the builders.
func (m *StockingLogMutation) MedicineIDs() (ids []int) {
	if id := m.medicine; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMedicine resets all changes to the "medicine" edge.
func (m *StockingLogMutation) ResetMedicine() {
	m.medicine = nil
	m.clearedmedicine = false
}

// SetActiveIngredientID sets the "active_ingredient" edge to the ActiveIngredient entity by id.
func (m *StockingLogMutation) SetActiveIngredientID(id int) {
	m.active_ingredient = &id
}

// ClearActiveIngredient clears the "active_ingredient" edge to the ActiveIngredient entity.
func (m *StockingLogMutation) ClearActiveIngredient() {
	m.clearedactive_ingredient = true
}

// ActiveIngredientCleared reports if the "active_ingredient" edge to the ActiveIngredient entity was cleared.
func (m *StockingLogMutation) ActiveIngredientCleared() bool {
	return m.clearedactive_ingredient
}

// ActiveIngredientID returns the "active_ingredient" edge ID in the mutation.
func (m *StockingLogMutation) ActiveIngredientID() (id int, exists bool) {
	if m.active_ingredient != nil {
		return *m.active_ingredient, true
	}
	return
}

// ActiveIngredientIDs returns the "active_ingredient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActiveIngredientID instead. It exists only for internal usage by the builders.
func (m *StockingLogMutation) ActiveIngredientIDs() (ids []int) {
	if id := m.active_ingredient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActiveIngredient resets all changes to the "active_ingredient" edge.
func (m *StockingLogMutation) ResetActiveIngredient() {
	m.active_ingredient = nil
	m.clearedactive_ingredient = false
}

// Where appends a list predicates to the StockingLogMutation builder.
func (m *StockingLogMutation) Where(ps ...predicate.StockingLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StockingLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StockingLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StockingLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StockingLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StockingLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StockingLog).
func (m *StockingLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StockingLogMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.stocked_at != nil {
		fields = append(fields, stockinglog.FieldStockedAt)
	}
	if m.boxes != nil {
		fields = append(fields, stockinglog.FieldBoxes)
	}
	if m.units != nil {
		fields = append(fields, stockinglog.FieldUnits)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StockingLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stockinglog.FieldStockedAt:
		return m.StockedAt()
	case stockinglog.FieldBoxes:
		return m.Boxes()
	case stockinglog.FieldUnits:
		return m.Units()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StockingLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stockinglog.FieldStockedAt:
		return m.OldStockedAt(ctx)
	case stockinglog.FieldBoxes:
		return m.OldBoxes(ctx)
	case stockinglog.FieldUnits:
		return m.OldUnits(ctx)
	}
	return nil, fmt.Errorf("unknown StockingLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockingLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stockinglog.FieldStockedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStockedAt(v)
		return nil
	case stockinglog.FieldBoxes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBoxes(v)
		return nil
	case stockinglog.FieldUnits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnits(v)
		return nil
	}
	return fmt.Errorf("unknown StockingLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StockingLogMutation) AddedFields() []string {
	var fields []string
	if m.addboxes != nil {
		fields = append(fields, stockinglog.FieldBoxes)
	}
	if m.addunits != nil {
		fields = append(fields, stockinglog.FieldUnits)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StockingLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case stockinglog.FieldBoxes:
		return m.AddedBoxes()
	case stockinglog.FieldUnits:
		return m.AddedUnits()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockingLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case stockinglog.FieldBoxes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBoxes(v)
		return nil
	case stockinglog.FieldUnits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnits(v)
		return nil
	}
	return fmt.Errorf("unknown StockingLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StockingLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(stockinglog.FieldStockedAt) {
		fields = append(fields, stockinglog.FieldStockedAt)
	}
	if m.FieldCleared(stockinglog.FieldBoxes) {
		fields = append(fields, stockinglog.FieldBoxes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StockingLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StockingLogMutation) ClearField(name string) error {
	switch name {
	case stockinglog.FieldStockedAt:
		m.ClearStockedAt()
		return nil
	case stockinglog.FieldBoxes:
		m.ClearBoxes()
		return nil
	}
	return fmt.Errorf("unknown StockingLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StockingLogMutation) ResetField(name string) error {
	switch name {
	case stockinglog.FieldStockedAt:
		m.ResetStockedAt()
		return nil
	case stockinglog.FieldBoxes:
		m.ResetBoxes()
		return nil
	case stockinglog.FieldUnits:
		m.ResetUnits()
		return nil
	}
	return fmt.Errorf("unknown StockingLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StockingLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.medicine != nil {
		edges = append(edges, stockinglog.EdgeMedicine)
	}
	if m.active_ingredient != nil {
		edges = append(edges, stockinglog.EdgeActiveIngredient)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StockingLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case stockinglog.EdgeMedicine:
		if id := m.medicine; id != nil {
			return []ent.Value{*id}
		}
	case stockinglog.EdgeActiveIngredient:
		if id := m.active_ingredient; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StockingLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StockingLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StockingLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmedicine {
		edges = append(edges, stockinglog.EdgeMedicine)
	}
	if m.clearedactive_ingredient {
		edges = append(edges, stockinglog.EdgeActiveIngredient)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StockingLogMutation) EdgeCleared(name string) bool {
	switch name {
	case stockinglog.EdgeMedicine:
		return m.clearedmedicine
	case stockinglog.EdgeActiveIngredient:
		return m.clearedactive_ingredient
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StockingLogMutation) ClearEdge(name string) error {
	switch name {
	case stockinglog.EdgeMedicine:
		m.ClearMedicine()
		return nil
	case stockinglog.EdgeActiveIngredient:
		m.ClearActiveIngredient()
		return nil
	}
	return fmt.Errorf("unknown StockingLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StockingLogMutation) ResetEdge(name string) error {
	switch name {
	case stockinglog.EdgeMedicine:
		m.ResetMedicine()
		return nil
	case stockinglog.EdgeActiveIngredient:
		m.ResetActiveIngredient()
		return nil
	}
	return fmt.Errorf("unknown StockingLog edge %s", name)
}
